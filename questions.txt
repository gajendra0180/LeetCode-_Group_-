Date:10/12/2021
Gajendra -https://leetcode.com/problems/merge-intervals/
Gajendra- https://leetcode.com/problems/sort-colors/submissions/
Karan -https://leetcode.com/problems/longest-substring-without-repeating-characters/
ASHISH - https://leetcode.com/problems/next-permutation/

----------------------------------------------------------


//ASHISH
//first soln
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& v) {
        if(v.size()==1){return v;}
      sort(v.begin(),v.end());
        vector<vector<int>> ans;
        ans.push_back(v[0]);
        for(int i = 1; i<v.size(); i++){
            
            if(ans.back()[1]<v[i][0]){
                ans.push_back({v[i][0],v[i][1]});
            }
            else{
                int new_first = ans.back()[0];
                int new_second = max(ans.back()[1],v[i][1]);
                ans.pop_back();
                ans.push_back({new_first,new_second});
            }
            
            
        }
        return ans;
    }
};

//2nd soln

class Solution {
public:
    void sortColors(vector<int>& nums) {
    int zero = 0;
    int one = 0;
    int two = 0;
    for(auto x: nums){
        if(x==0){zero++;}
        else if(x==1){one++;}
        else{two++;}
    }
    for(int i =0; i<nums.size(); i++){
        if(zero){
            nums[i] = 0;
            zero--;
        }
        else if(one){
            nums[i] = 1;
            one--;
        }
        else{
            nums[i] = 2;
            two--;
        }
    }

    }
};



//3rd solution

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       if(s.length()==0 || s.length()==1){
           return s.length();
       }
        
        map<char,int> store;
        for(int i =0; i<s.length();i++){
            store[s[i]] = i;
        }
       
     
        vector<int>ans;
        for(int i =0; i<s.length();i++){
            ans.push_back(0);
        }
        ans[s.length()-1] = 1;
        for(int i = s.length()-2;i>=0;i--){
            if(store[s[i]]>i){
                
             int xx = store[s[i]]-i;
             int yy = ans[i+1]+1;
                ans[i] = min(xx,yy);
                store[s[i]] = i;
            }
            else if(store[s[i]]<=i){
                ans[i]=ans[i+1]+1;
                
                 store[s[i]] = i;
                
            }
        }
        sort(ans.begin(),ans.end());
        return ans[ans.size()-1];
        
    }
};

-------------------------------------------------------------------




Dated: 11/12/2021


Questions:
Gajendra-https://leetcode.com/problems/nth-magical-number/
Arpit- https://leetcode.com/problems/count-complete-tree-nodes/submissions/
Karan - https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

Ashish-
https://leetcode.com/problems/swap-nodes-in-pairs/





Solutions:

----------------------------------------------------------------------------

Ashish:
my que soln:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
       if(head==NULL || head->next==NULL){
           return head;
       } 
        
        ListNode* pre = NULL;
        ListNode* pos = head;
        while(pos!=NULL){
            if(pre==NULL){
                 if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre = pos;
                head = mid;
                pos = st;
            }
            else{
                if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre->next = mid;
                pre = pos;
                pos = st;
                
            }
            
            
        }
        return head;
    }
};



Ashish : karan's que ans
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define tn TreeNode
class Solution {
public:
    TreeNode* recoverFromPreorder(string t) {
        
        int d = 0;
        int v = 0;
        map<tn*,int> map_dist;
        map<tn*,vector<int>> map_allow;
        tn* root = NULL;
        stack<tn*> myset;
    
        for(auto x: t){
          
            if(x!='-'){
                v = v*10+(x-'0');
                
              
               
             
            }
            else{
            
               if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                       continue;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
                
                
                d++;
                
                
                
            }
        }
        
        if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                      return root;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
        return root;
        
        
    }
};

ASHISH: Gajendra que ans
#define ll long long
ll gcd(ll a, ll b){
    if(a==0){return b;}
    if(b==0){return a;}
    return gcd(b, a%b);
}
ll lcm(ll a, ll b){
    return (a*b)/gcd(a,b);
}
class Solution {
public:
    int nthMagicalNumber(int nn, int a, int b) {
        ll aa = (ll)a;
        ll bb = (ll)b;
        ll n = nn;
        ll left = 1;
        ll k = lcm(aa,bb);
        ll right = 1e18;
        ll ans = 1e18;
        while(left<=right){
            ll mid = (left+right)/2;
            ll target = (mid/aa)+(mid/bb)-(mid/k);
            if(target<n){
                left = mid+1;
            }
            else{
                if(target==n){
                    ans = min(ans, mid%(1000000007));
                }
                right = mid-1;
            }
           
        }
       return ans; 
    }
};


Arpit:
Solution 2nd question
class Solution {
public:
    int heightl(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->left;
      }
        return h;
    }
     int heightr(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->right;
      }
        return h;
    }
    int countNodes(TreeNode* root) {
        if(root==NULL)
            return 0;
        int l=heightl(root);
        int r=heightr(root);
        if(l==r){
          return pow(2,l)-1;
        }
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

Solution 3rd question
class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
        
        map<string,pair<TreeNode*,int>>m;
            int num=0;string v="";
        TreeNode* z=NULL;int x;
        TreeNode* root=NULL;
        for(int i=0;i<s.length();i++){
            if(s[i]>=48 && s[i]<=57){
                 num=0;
                while(i<s.length() && s[i]>=48 && s[i]<=57){
                    num=num*10+(s[i]-48);
                    i++;
                }
                i--;
                  z=new TreeNode(num);
                if(root==NULL)
                    root=z;
                else{
                  root=m[v].first;
                  x=m[v].second;
                    if(x==0){
                        root->left=z;
                    }
                    if(x==1){
                        root->right=z;
                    }
                }
            }
            else{
               int l=v.length();
                 v="";
               while(s[i]=='-'){
                   v.push_back('-');
                   i++;
               }
               int u=v.length();
                i--;
                if(m.find(v)==m.end()){
                    m[v]={z,0};
                }
                else if(m.find(v)!=m.end() && m[v].second!=1){
                    m[v].second++;
                }
                else{
                    m[v]={z,0};
                }
                if(l>u){
                for(auto it=++m.find(v);it!=m.end();it++){
                    (*it).second.second=1;
                }
                }
            }
        }
        if(m.size()==0){
            return z;
        }
        auto pair=m["-"];
        return pair.first;
    }
};



Gajendra:
1st ques:
class Solution {
public:
    
    
    bool condition(long long int mid,long long int req,long long int a,long long int b,long long lcm)
    {
        long long int posx=mid/a+mid/b-(mid/lcm);
        if(posx<req)
            return false;
        return true;
    }
    
    int nthMagicalNumber(int n, int a, int b) {
        long long int gcd=__gcd(a,b);
        long long int lcm=a*b/gcd;
       long long int left=1,right=1e18;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            if(condition(mid,n,a,b,lcm))
                right=mid;
            else
                left=mid+1;
        }
        int mod=1e9+7;
        return left%mod;
    }
};

2nd ques:
class Solution {
public:
    int lheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+lheight(root->left);
    }
    
    int rheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+rheight(root->right);
    }
    int countNodes(TreeNode* root) {
      
        if(!root)return 0;
        
        int l=lheight(root->left);
        int r=rheight(root->right);

        
        if(l==r)
            return pow(2,l+1)-1;
        
        cout<<l<<" "<<r<<endl;
        
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

3rd question:


class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
     
        map<int,TreeNode*> m;
        int current_level=0,chk=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]=='-')
                current_level++;
            else
            {
                string num;
                while(i<s.size()&&s[i]>='0'&&s[i]<='9')
                {
                    num.push_back(s[i]);
                    i++;
                }
                
                i--;
                
                stringstream ss;
                ss<<num;
                int n;
                ss>>n;
                
                TreeNode* temp=new TreeNode(n);
                
                m[current_level]=temp;
                
                if(current_level){
                    
                if(m[current_level-1]->left)
                    m[current_level-1]->right=temp;
                else
                    m[current_level-1]->left=temp;
                }
                current_level=0;
            }
        }
        return m[0];
    }
};

-----------------------------------------------------------------------------

<<<<<<< HEAD
=======

>>>>>>> 220a8bba66c07ac446287a9879dd949553d41b73



Date:12/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/ugly-number-iii
Ashish->   https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
Karan-> https://leetcode.com/problems/letter-combinations-of-a-phone-number/

-------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

1st ques:
class Solution {
public:
    
    bool condition(long long int mid,long long int l1,long long int l2,long long int l3,long long int l4,long long int a,long long int b,long long int c,long long int req)
    {
        long long int n=mid/a+mid/b+mid/c-mid/l1-mid/l2-mid/l3+mid/l4;
        // cout<<mid<<" "<<n<<endl;
        if(n<req)
            return false;
        return true;
    }
    
    int nthUglyNumber(long long int n, long long int a, long long int b, long long int c) {
        long long int left=1,right=1e18;
        long long int lcm1=(a*b)/__gcd(a,b);
        long long int lcm2=(b*c)/__gcd(b,c);
        long long int lcm3=(a*c)/__gcd(a,c);
        long long int lcm4=a*lcm2/(__gcd(a,lcm2));
        // cout<<lcm1<<lcm2<<lcm3<<lcm4<<endl;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            // cout<<left<<" @ "<<right<<endl;
            if(condition(mid,lcm1,lcm2,lcm3,lcm4,a,b,c,n))
                right=mid;
            else
                left=mid+1;
        }
        return left;
        
    }
};

2nd ques:

class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& v, int startPos, int k) {
        unordered_map<int,int> m;
        for(auto i:v)m[i[0]]=i[1];
         int sum1=m[startPos];
        for(int i=startPos+1;i<=k+startPos;i++)
            sum1+=m[i];
         int res=sum1;
        int left=startPos-1,right=startPos+k;
        while(left>=0&&left<right)
        {
            res=max(res,sum1);
            sum1-=m[right];
            right--;
            sum1-=m[right];
            right--;
            sum1+=m[left];
            left--;
        }
            res=max(res,sum1);
            sum1=m[startPos],left=startPos-k,right=startPos+1;
            for(int i=startPos-1;i>=startPos-k;i--)
               sum1+=m[i];
        
          while(right<=v.back()[0]&&left<right)
           {
               res=max(res,sum1);
               sum1-=m[left];
               left++;
               sum1-=m[left];
               left++;
               sum1+=m[right];
               right++;
           }
            res=max(res,sum1);
        return res;
        
    }
};
Arpit
solution 1st question:-
class Solution {
public:
 int nthUglyNumber(int n, int a, int b, int c) {
       int start=1;
        int end=a*n;
        long int ab=(long int)a*b/gcd(a,b);
      long  int bc=(long int)c*b/gcd(c,b);
        long int ca=(long int)a*c/gcd(a,c);
         long int abc=(long int)a*bc/gcd(a,bc);
        while(start<end){
            int mid=start+(end-start)/2;
           int total=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ca+mid/abc;
           cout<<total<<" ";
            if(total<n){
                start=mid+1;
            }
            else
                end=mid;
        }
        return end;
    }
};
solution 3rd question:-
class Solution {
public:
     vector<string> v={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    
    vector<string> lc(string s){
          vector<string>m;
        if(s.length()==0){
            m.push_back(""); 
            return m;
        }
        char ch=s[0];
        string sub=s.substr(1);
         m=lc(sub);
        vector<string>res;
        string rstr=v[ch-'0'];
        for(int i=0;i<rstr.length();i++){
            char cha =rstr[i];
            for(string c:m){
                res.push_back(cha+c);
            }
        }
        return res;
    }
    
    vector<string> letterCombinations(string s) {
        vector<string> res;
        if(s.size()==0) return res;
         res=lc(s);
        return res;
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------


<<<<<<< HEAD
Ashish->
https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
=======

Date:13/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/partition-equal-subset-sum/
Arpit -> https://leetcode.com/problems/path-sum-iii/
Ashish -> https://leetcode.com/problems/zigzag-conversion/
Karan -> https://leetcode.com/problems/construct-string-from-binary-tree/
------------------------------------------------------------------------------------------------------------------------------------------------------------

Solutions:

From Gajendra:
1st: 
class Solution {
public:
        struct HASH{
	size_t operator()(const pair<int,int> &x)const{
		return hash<int>()(x.first^x.second);
	}
};
    unordered_map<pair<int,int>,int,HASH> m;
    bool can(int sum,vector<int>&v,int i,int req)
    {
        if(i>=v.size())
            return false;
        if(sum==req)
            return true;
        if(sum>req)
            return false;
        
        if(m.find({i,sum})!=m.end())
            return m[{i,sum}];
        
        return m[{i,sum}]=can(sum+v[i],v,i+1,req)||can(sum,v,i+1,req);
    }
    
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(auto i:nums)sum+=i;
        if(sum%2==0)
        {
            sum/=2;
            if(can(0,nums   ,0,sum))
                return true;
        }            
        return false;
    }
};
2nd:
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1)
            return s;
        bool decreasing=false;
        vector<vector<char>>v;
        for(int i=0;i<numRows;i++)
        {
            vector<char> temp;
            for(int j=0;j<s.length();j++)
            {
              temp.push_back(' ');  
            }
            v.push_back(temp);
        }
        int row=0,col=0;
        for(auto i:s)
        {
            if(decreasing)
            {
                col++;
                v[row][col]=i;
                row--;
                if(row<=0)
                {decreasing=false;row=0;col++;}
            }
            else
            {
                v[row][col]=i;
                if(row==numRows-1)
                {
                    decreasing=true;row--;
                }
                else
                    row++;
                if(row==0)
                {
                    decreasing=false;col++;
                }
            }
        }
        string res;
        for(auto i:v)
        {
            for(auto j:i)
            {
                // cout<<j<<" ";
                if(j!=' ')
                res.push_back(j);
            }
            // cout<<endl;
        }
        return res;
    }
};
3rd:


class Solution {
public:
    
    void solve(TreeNode* root,int targetSum,map<int,int> m,int &res,int currSum)
    {
        if(root==NULL)
            return;
        currSum+=root->val;
        
        int req=currSum-targetSum;
        
        if(m.find(req)!=m.end())
            res+=m[req];
        
        m[currSum]++;
        
        solve(root->left,targetSum,m,res,currSum);
        solve(root->right,targetSum,m,res,currSum);
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        int res=0;
        map<int,int> m;
        m[0]=1;
        solve(root,targetSum,m,res,0);
        return res;
    }
};


4th:

class Solution {
public:
    void t(TreeNode* r,string &res)
    {
        if(!r)
            return;

        stringstream ss;
        ss<<r->val;
        string num;ss>>num;
        
        res+=num;
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back('(');
        
        t(r->left,res);     
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back(')');
        
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back('(');

        t(r->right,res); 
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back(')');
        
    }
    
    string tree2str(TreeNode* root) {
        string res;
        t(root,res);
        return res;
        
    }
};



Arpit's
solution ques2:-
class Solution {
public:
    int ct=0;
    int p=1;
    void func(TreeNode* root,int s){
        if(root==NULL) return ;
        if(root->val==s){ ct++;}
        func(root->left,s-root->val);
        func(root->right,s-root->val);
    }
    void helper(TreeNode* root,int targetSum){
        if(root==NULL) return;
         func(root->left,targetSum);
         func(root->right,targetSum);
        helper(root->left,targetSum);
        helper(root->right,targetSum);        
    }
    int pathSum(TreeNode* root, int targetSum) {
       if(root==NULL) return 0;
        if(p) {
             func(root,targetSum);
            p=0;
        }
       helper(root,targetSum);
        return ct;
    }
};






From Ashish
gajendra que's soln
bool check(vector<int>&nums, int sum, int n,vector<vector<int>>&dp){
    if(sum<0){
        return false;
    }
    if(sum==0){
        return true;
    }
    if(n==0){
        return false;
    }
    if(dp[sum][n]!=-1){
        return dp[sum][n];
    }
    bool x = check(nums, sum-nums[n-1],n-1,dp);
    bool y = check(nums, sum, n-1,dp);
    dp[sum][n] = (x|y);
    return dp[sum][n];
    
}

class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto x: nums){
            sum+=x;
        }
        if(sum&1){
            return false;
        }
        sum/=2;
        
        vector<int>dpp(nums.size()+1,-1);
        vector<vector<int>> dp(sum+1,dpp);
        return check(nums,sum,nums.size(),dp);
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------



Date: 14/12/2021

Questions:
Gajendra-> https://leetcode.com/problems/range-sum-of-bst/
Arpit-> https://leetcode.com/problems/delete-node-in-a-bst/
Karan -> https://leetcode.com/problems/my-calendar-i/
Ashish-> https://leetcode.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/


---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra
1st :
class Solution {
public:
    int res=0;
    void traverse(TreeNode* r,int low,int high)
    {
        if(r==NULL)
            return;
        if(r->val>=low&&r->val<=high)
            res+=r->val;
        if(r->val>=low&&r->val<=high)
        {
            traverse(r->left,low,high);
            traverse(r->right,low,high);
        }
        else if(r->val<low)
            traverse(r->right,low,high);
        else if(r->val>high)
            traverse(r->left,low,high);

    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        traverse(root,low,high);
        return res;
    }
};

2nd:
class Solution {
public:
    TreeNode* findMin(TreeNode* r)
    {
        while(r->left!=NULL)    
            r=r->left;
        return r;
    }
    void del_node(TreeNode* &r,TreeNode*  d)
    {
        if(r==NULL)return;
        if(r->left==d)
        {
            
            r->left=r->left->right;
            return;
        }
      if(r->right==d)
        {
            r->right=r->right->right;
            return;
        }
        del_node(r->left,d);
        del_node(r->right,d);
        
    }
    void dn(TreeNode* &r,int k,TreeNode* tab)
    {
        if(r==NULL)
            return;
        
        if(r->val==k)
        {
            if(r->left==NULL&&r->right==NULL)
            {
              //leaf node
                // del_node(tab,r);
                r=r->right;
                return;
            }
            else if(r->right==NULL&&r->left!=NULL)
            {
                r=r->left;
                return;
            }
            TreeNode* temp=(findMin(r->right));
            cout<<temp->val;
            TreeNode* gp=temp;
            del_node(r,temp);
            r->val=gp->val;
            return;
        }
        dn(r->left,k,tab);
        dn(r->right,k,tab);
        
    }
    
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if(root==NULL)
            return root;
        
        if(root->val==key&&root->left==NULL&&root->right==NULL)
            return NULL;

        dn(root,key,root);
        
        return root;
        
    }
};
3rd:
class MyCalendar {
    map<int, int>bookings;
public:    
    bool book(int s1, int e1) {
        
        for(auto  i: bookings) 
        {
            int s2=i.first;
            int e2=i.second;
            if( s1 < e2 && s2 < e1 )   
			    return false; 
        }
        bookings[s1] = e1;                
        return true;
    }
};




Arpit's solution 2nd question:-
class Solution {
public:
    TreeNode* minvalright(TreeNode* root){
        while(root->left){
            root=root->left;
        }
        return root;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return root;
        if(key<root->val){
            root->left=deleteNode(root->left,key);
        }
        else if(key>root->val){
            root->right=deleteNode(root->right,key);
        }
        else{
            TreeNode* temp=NULL;
            if(root->left==NULL){
                temp=root->right;
                delete root;
                return temp;
            }
            else if(root->right==NULL){
                temp=root->left;
                delete root;
                return temp;
            }
            else{
             temp=minvalright(root->right);
            root->val=temp->val;
            root->right=deleteNode(root->right,temp->val);
            }
        }
        return root;
    }
};


-----------------------
Ashish : Gajendra que soln:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
void finder(TreeNode* root, int &sum,int low, int max){
    
    if(root==NULL){return;}
    if(root->val>=low && root->val<=max){
        sum+=root->val;
    }
    if(root->val>=max){
       finder(root->left,sum,low,max); 
    }
    else if(root->val<=low){
        finder(root->right,sum,low,max);
    }
   
   else{
       finder(root->left,sum,low,max);
       finder(root->right,sum,low,max);
   }
    
    
}
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int sum = 0;
        finder(root,sum,low,high);
        return sum;
    }
};


ASHISH : arpit's que
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    int minFinder(TreeNode* root){
       
        int tt = root->val;
        while(root){
            tt = min(tt,root->val);
            root = root->left;
        }
        return tt;
    }
    TreeNode* deleteNode(TreeNode* &root, int key) {
        if(root==NULL){return NULL;}
        if(root->val==key && root->right==NULL){
            return root->left;
        }
        if(root->val==key && root->left==NULL){
            return root->right;
        }
        if(root->val==key){
            int pending = minFinder(root->right);
            root->val = pending;
            root->right = deleteNode(root->right,pending);
            return root;
        }
        
        if(root->val>key){
            root->left = deleteNode(root->left,key);
            return root;
        }
          root->right = deleteNode(root->right,key);
          return root;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------
<<<<<<< HEAD


Date: 15/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/insertion-sort-list/
Karan -> https://leetcode.com/problems/fraction-to-recurring-decimal/

ASHISH: 
https://leetcode.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/

<<<<<<< HEAD



OLD QUE  OF KARAN
my calender 1 soln from ashish

class MyCalendar {
public:
    // just a map to take care of interval of prev books
    map<int,int> track;
    MyCalendar() {
        
    }
    
//     try to understand this concept like if there are two intervals like   7----->10  and 2--------->10 so its beneficial to take 2-----> 10 in track map since 7 lies between them so track map has key as ending of event and value as minimum time of beginnig of event 
    
    
    
    
    bool book(int start, int end) {
        end--;
        for(auto x: track){
            if(x.first>=start){
//                checking any interval found with which given slot is overlapping or not 
                    if(x.second<=end){
                        return false;
                    }
                
            }
        }
        
        // here we are checking ending time is already in track map in that case we will just try to minimise the beginning time 
        if(track.find(end)!=track.end()){
            track[end] = min(start,track[end]);
        }
        else{
            track[end] = start;
        }
        return true;
        
        
    }
};

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */






Date: 17/12/2021

Questions: 

Gajendra -> https://leetcode.com/problems/maximal-square/
Karan -> https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
<<<<<<< HEAD
=======


------------------------------------------------------------------------------------------------------------------------------------------

Solution:

2nd ques(Karan):
class Solution {
public:
    int minAddToMakeValid(string s) {
        int gp=0,res=0;
        for(auto i:s)
        {
            if(i=='(')
                gp++;
            else
            {
               
                if(gp<=0)
                    res++;
                else
                     gp--;
            }
        }
        return res+gp;
    }
};

------------------------------------------------------------------------------------------------------------------------------------------


18 dec 

questions:

ASHISH -> https://leetcode.com/problems/container-with-most-water/


------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Gajendra
1st quest:
class Solution {
public:
    int maxArea(vector<int>& v) {
        int left=0,right=v.size()-1;
        int maxx=0;
        while(left<=right)
        {
            int quantity=(right-left)*(min(v[left],v[right]));
            if(v[left]<=v[right])
                left++;
            else

                right--;
            maxx=max(quantity,maxx);
        }
        return maxx;
    }
};


_------------------------------------------------------------------------------------------------------------------------------------------------




Date:19/12/2021

Questions:
Gajendra-> https://leetcode.com/contest/weekly-contest-272/problems/minimum-operations-to-make-the-array-k-increasing/
	  Hints: b)  https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
		 a)  https://www.geeksforgeeks.org/convert-to-strictly-increasing-integer-array-with-minimum-changes/
------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:
1)
class Solution {
public:
  
int CeilIndex(vector<int>& v, int l, int r, int key)
{
    return upper_bound(v.begin(),v.begin()+r,key)-v.begin();
}
 
int lis(vector<int>& v)
{
    if (v.size() == 0)
        return 0;
 
    vector<int> tail(v.size(), 0);
    int length = 1; // always points empty slot in tail
 
    tail[0] = v[0];
    for (size_t i = 1; i < v.size(); i++) {
 
        // new smallest value
        if (v[i] < tail[0])
            tail[0] = v[i];
 
        else if (v[i] >= tail[length - 1])
            tail[length++] = v[i];
 
        else
            tail[CeilIndex(tail, 0, length - 1, v[i])] = v[i];
    }
 
    return length;
}
    
    int kIncreasing(vector<int>& arr, int k) {
     
        int n=arr.size(),res=0;
        for(int i=0;i<k;i++)
        {
            vector<int> v;
            for(int j=i;j<n;j+=k)
                v.push_back(arr[j]);
            res+=v.size()-lis(v);
        }
        return res;
        
    }
};

----------------------------------------------------------------------------------------------------------------------------------------------


Date:20/12/2021

Questions:

Gajendra->https://leetcode.com/problems/decode-string/
Ashish -> https://leetcode.com/problems/3sum-closest/description/
Karan -> https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/
---------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra:
1) 
class Solution {
public:
    string tmp(string s,int &i)
    {
        string res="";
        if(i>=s.length())
            return res;
        while(i<s.length())
        {
            if(isalpha(s[i]))
               res.push_back(s[i]);
             else if(s[i]==']')
               return res;
              else if(isdigit(s[i]))
               {
                   string num="";
                   while(isdigit(s[i]))
                       num.push_back(s[i++]);
                   stringstream ss;
                   ss<<num;int n;ss>>n;
                   string ans=tmp(s,++i);
                   for(int j=0;j<n;j++)
                       res+=ans;
                  cout<<ans<< n <<res<<endl;
               }
               i++;
        }
        return res;
    }
    string decodeString(string s) {
        int i=0;
        return tmp(s,i);
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------
Date : 21/12/2021

Questions:

Karan-> https://leetcode.com/problems/power-of-two/
Gajendra -> https://leetcode.com/problems/merge-intervals/


---------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter: karan

class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n>0?!(n&(n-1)):false;
    }
};

Setter: Gajendra

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
       sort(intervals.begin(),intervals.end());
        vector<vector<int>>res;
        res.push_back({intervals[0][0],intervals[0][1]});
        for(int i=1;i<intervals.size();i++)
        {
            if(res.back()[1]>=intervals[i][0])
                res.back()[1]=max(res.back()[1],intervals[i][1]);
            else
                res.push_back({intervals[i][0],intervals[i][1]});
        }
        return res;
    }
};

Solver: Gajendra
Setter: Ashish
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> res{nums[0]};
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>res.back())
                res.push_back(nums[i]);
            else
            {
                auto ind=lower_bound(res.begin(),res.end(),nums[i])-res.begin();
                res[ind]=nums[i];
            }
        }
        return res.size();
    }
    
};


-----------------------------------------------------------------------------------------------------------------------------------------------------


Questions from Ashish:
https://leetcode.com/problems/longest-increasing-subsequence/

------------------------------------------------------------------------





Date : 22/12/2021

Questions:

Gajendra-> https://leetcode.com/problems/design-hashmap/submissions/ 
Karan -> https://leetcode.com/problems/reorder-list/submissions/



----------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra

class MyHashMap {
public:
    int arr[1000001];
    MyHashMap() {
    for(int i=0;i<1000001;i++)
      arr[i]=-1;
    }
    
    void put(int key, int value) {
        arr[key]=value;
    }
    
    int get(int key) {
        return arr[key];
    }
    
    void remove(int key) {
        arr[key]=-1;
    }
};


-----------------------------------------------------------------------------------------------------------------------------------------------------

ASHISH's que :

https://leetcode.com/problems/group-anagrams/submissions/


SOLVER : ASHISH
SETTER : ASHISH

class Solution {
public:
  // map for storing value as arr of  strings which is anagrams of key 
  map<string,vector<string>> str_store; 
    
//  here making  a function that takes string s in addition to str_store(defined above)
//     it will make a copy of string s as t after that it will sort that then just map....
void  checker(map<string,vector<string>> &str_store,string s){
    string t = s;
    sort(t.begin(),t.end());
   str_store[t].push_back(s);  
}
       
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
//         iterating over all strings  and then  appling checker function (explained above)
        for(auto x: strs){
            checker(str_store,x);
        }
// now returning vector of vector  as answer
        vector<vector<string>> ans;
        for(auto x: str_store){
            ans.push_back(x.second);
        }
        
        
        return ans;
    }
};




QUE FROM ASHISH
https://leetcode.com/problems/course-schedule-ii/
Solution from Gajendra for course-schedule-ii:
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& v) {
            map<int, vector<int>> g;
            map<int, int> indegree;
        for(auto i:v)
        {
            indegree[i[0]]++;
            g[i[1]].push_back(i[0]);
        }
        vector<int> res;
        int vis_count = 0;
        deque<int> dq;
        for (int i = 0; i <numCourses; i++)
            if (indegree[i] == 0)
                dq.push_back(i);
        while (dq.size())
        {
            auto u = dq.front();
            dq.pop_front();
            cout<<u;
            res.push_back(u);
            vis_count++;
            for (auto v : g[u])
            {
                indegree[v]--;
                if (indegree[v] == 0)
                    dq.push_back(v);
            }
        }
        if(vis_count!=numCourses)
            return {};
        return res;
    }
};







Date : 24/12/2021

Questions :

Karan -> https://leetcode.com/problems/min-stack/
Gajendra -> https://leetcode.com/problems/palindromic-substrings/
ASHISH -> https://leetcode.com/problems/integer-to-roman/submissions/




--------------------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra

class Solution {
public:
    int countSubstrings(string s) {
        int res=0;
        for(int i=0;i<s.length();i++)
        {
            int left=i-1,right=i+1;
            res++;
            while(left>=0&&right<s.length()&&s[left--]==s[right++])res++;
            left=i,right=i+1;
            while(left>=0&&right<s.length()&&s[left--]==s[right++])res++;
        }
        return res;
    }
};

Solver:Gajendra
Setter:Karan

class MinStack:
    
    def __init__(self):
        self.stack=[]
        self.minn=2**31+1

    def push(self, val: int) -> None:
        self.minn=min(self.minn,val)
        self.stack.append((val,self.minn))

    def pop(self) -> None:
        self.stack.pop()
        if len(self.stack)==0:
            self.minn=2**31+1
        else:
            self.minn=self.stack[-1][1]

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]
	
	
Solver:Arpit
Setter:Aashish
class Solution {
public:
    string intToRoman(int num) {
    string M[] = {"", "M", "MM", "MMM"};
    string C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    string X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    string I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
    }
};

---------------------------------------------------------------------------------------------------------------------------------------------------------------


Date:25/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/course-schedule/
Arpit -> https://leetcode.com/problems/regular-expression-matching/
Gajendra -> https://leetcode.com/problems/find-eventual-safe-states/submissions/
Karan -> https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver->Arpit
Setter->Arpit
class Solution {
public:
    bool isMatch(string s, string p) {
      if(p.length()==0){
          return s.length()==0;
      } 
      if(p.length()>1 && p[1]=='*'){
          if(isMatch(s,p.substr(2))){
              return true;
          }
          if(s.length()>0 && (s[0]==p[0] || p[0]=='.')){
             return isMatch(s.substr(1),p);
          }
          return false;
      }
        else{
            if(s.length()>0 && (s[0]==p[0] || p[0]=='.')){
               return isMatch(s.substr(1),p.substr(1));
            }
                return false; 
        }
        return true;
    }
};

Solver -> Gajendra
Setter ->Gajendra

class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& v) {
            map<int, vector<int>> g;
            map<int, int> indegree;
        for(auto i:v)
        {
            indegree[i[0]]++;
            g[i[1]].push_back(i[0]);
        }
        int vis_count = 0;
        deque<int> dq;
        for (int i = 0; i <numCourses; i++)
            if (indegree[i] == 0)
                dq.push_back(i);
        while (dq.size())
        {
            auto u = dq.front();
            dq.pop_front();
            cout<<u;
            vis_count++;
            for (auto v : g[u])
            {
                indegree[v]--;
                if (indegree[v] == 0)
                    dq.push_back(v);
            }
        }
        if(vis_count==numCourses)
            return true;
        return false;
    }
};

Setter -> Gajendra
Solver -> Gajendra

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
           map<int, vector<int>> g;
            map<int, int> indegree;
        
            for(int i=0;i<graph.size();i++)
            {
                for(auto j:graph[i])
                {
                    g[j].push_back(i);
                    indegree[i]++;
                }
            }
            vector<int> res;
            deque<int> dq;
            for (int i = 0; i <graph.size(); i++)
                if (indegree[i] == 0)
                    dq.push_back(i);
            while (dq.size())
            {
                auto u = dq.front();
                dq.pop_front();
                res.push_back(u);
                for (auto v : g[u])
                {
                    indegree[v]--;
                    if (indegree[v] == 0)
                        dq.push_back(v);
                }
            }
            sort(res.begin(),res.end());
            return res;
    }
};


---------------------------------------------------------------------------------------------------------------------------------------------------------------


Date: 26/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/recover-the-original-array/
Karan -> https://leetcode.com/problems/k-closest-points-to-origin/

--------------------------------------------------------------------------------------------------
Solutions:

Solver -> Gajendra
Setter ->Gajendra

class Solution {
public:
    vector<int> recoverArray(vector<int>& nums) {
        vector<int> k;
        sort(nums.begin(),nums.end());
        int child=nums[0];
        for(auto i:nums)
        {
            int x=i-child;
            if(x%2==0&&x!=0)
            k.push_back(x/2);
        }
        int res=0;
        for(auto kk:k)
        {
          unordered_map<int,int> m;
            for(auto i:nums)
                m[i]++;
            for(auto i:nums)
            {
                if(m.find(i)!=m.end())
                m[i]--;
                else
                continue;
               
                if(m.find(i+2*kk)!=m.end())
                    m[i+2*kk]--;
                else
                    break;
               if(m[i]==0)m.erase(i);
                if(m[i+2*kk]==0)
                    m.erase(i+2*kk);
            }
            if(m.size()==0)
            {
             res=kk;break;
            }
        }
        vector<int>result;
         unordered_map<int,int> m;
            for(auto i:nums)
                m[i]++;
             for(auto i:nums)
            {
             if(m.find(i)!=m.end())
             {m[i]--;result.push_back(i+res);}
                else
                continue;
                if(m[i]==0)m.erase(i);
                if(m.find(i+2*res)!=m.end())
                    m[i+2*res]--;
                else
                    continue;
                if(m[i+2*res]==0)
                    m.erase(i+2*res);
            }
        return result;
    }
};

Solver -> Gajendra
Setter -> Karan

class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        map<int,vector<vector<int>>> m;
        for(auto i:points)
        {
            int x=i[0],y=i[1];
            int gp=x*x+y*y;
            m[gp].push_back({x,y});
        }
        vector<vector<int>> res;
        for(auto i:m)
        {
            for(auto j:i.second)
            {
                k--;res.push_back({j[0],j[1]});
            }
            if(k==0)
                break;
        }
        return res;
    }
};


----------------------------------------------------------------------------------------------------



Date: 27/12/2021

Questions:

Gajendra -> https://leetcode.com/problems/basic-calculator-ii/
