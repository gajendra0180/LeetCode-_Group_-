Date:10/12/2021
Gajendra -https://leetcode.com/problems/merge-intervals/
Gajendra- https://leetcode.com/problems/sort-colors/submissions/
Karan -https://leetcode.com/problems/longest-substring-without-repeating-characters/
ASHISH - https://leetcode.com/problems/next-permutation/

----------------------------------------------------------


//ASHISH
//first soln
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& v) {
        if(v.size()==1){return v;}
      sort(v.begin(),v.end());
        vector<vector<int>> ans;
        ans.push_back(v[0]);
        for(int i = 1; i<v.size(); i++){
            
            if(ans.back()[1]<v[i][0]){
                ans.push_back({v[i][0],v[i][1]});
            }
            else{
                int new_first = ans.back()[0];
                int new_second = max(ans.back()[1],v[i][1]);
                ans.pop_back();
                ans.push_back({new_first,new_second});
            }
            
            
        }
        return ans;
    }
};

//2nd soln

class Solution {
public:
    void sortColors(vector<int>& nums) {
    int zero = 0;
    int one = 0;
    int two = 0;
    for(auto x: nums){
        if(x==0){zero++;}
        else if(x==1){one++;}
        else{two++;}
    }
    for(int i =0; i<nums.size(); i++){
        if(zero){
            nums[i] = 0;
            zero--;
        }
        else if(one){
            nums[i] = 1;
            one--;
        }
        else{
            nums[i] = 2;
            two--;
        }
    }

    }
};



//3rd solution

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       if(s.length()==0 || s.length()==1){
           return s.length();
       }
        
        map<char,int> store;
        for(int i =0; i<s.length();i++){
            store[s[i]] = i;
        }
       
     
        vector<int>ans;
        for(int i =0; i<s.length();i++){
            ans.push_back(0);
        }
        ans[s.length()-1] = 1;
        for(int i = s.length()-2;i>=0;i--){
            if(store[s[i]]>i){
                
             int xx = store[s[i]]-i;
             int yy = ans[i+1]+1;
                ans[i] = min(xx,yy);
                store[s[i]] = i;
            }
            else if(store[s[i]]<=i){
                ans[i]=ans[i+1]+1;
                
                 store[s[i]] = i;
                
            }
        }
        sort(ans.begin(),ans.end());
        return ans[ans.size()-1];
        
    }
};

-------------------------------------------------------------------




Dated: 11/12/2021


Questions:
Gajendra-https://leetcode.com/problems/nth-magical-number/
Arpit- https://leetcode.com/problems/count-complete-tree-nodes/submissions/
Karan - https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

Ashish-
https://leetcode.com/problems/swap-nodes-in-pairs/





Solutions:

----------------------------------------------------------------------------

Ashish:
my que soln:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
       if(head==NULL || head->next==NULL){
           return head;
       } 
        
        ListNode* pre = NULL;
        ListNode* pos = head;
        while(pos!=NULL){
            if(pre==NULL){
                 if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre = pos;
                head = mid;
                pos = st;
            }
            else{
                if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre->next = mid;
                pre = pos;
                pos = st;
                
            }
            
            
        }
        return head;
    }
};



Ashish : karan's que ans
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define tn TreeNode
class Solution {
public:
    TreeNode* recoverFromPreorder(string t) {
        
        int d = 0;
        int v = 0;
        map<tn*,int> map_dist;
        map<tn*,vector<int>> map_allow;
        tn* root = NULL;
        stack<tn*> myset;
    
        for(auto x: t){
          
            if(x!='-'){
                v = v*10+(x-'0');
                
              
               
             
            }
            else{
            
               if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                       continue;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
                
                
                d++;
                
                
                
            }
        }
        
        if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                      return root;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
        return root;
        
        
    }
};

ASHISH: Gajendra que ans
#define ll long long
ll gcd(ll a, ll b){
    if(a==0){return b;}
    if(b==0){return a;}
    return gcd(b, a%b);
}
ll lcm(ll a, ll b){
    return (a*b)/gcd(a,b);
}
class Solution {
public:
    int nthMagicalNumber(int nn, int a, int b) {
        ll aa = (ll)a;
        ll bb = (ll)b;
        ll n = nn;
        ll left = 1;
        ll k = lcm(aa,bb);
        ll right = 1e18;
        ll ans = 1e18;
        while(left<=right){
            ll mid = (left+right)/2;
            ll target = (mid/aa)+(mid/bb)-(mid/k);
            if(target<n){
                left = mid+1;
            }
            else{
                if(target==n){
                    ans = min(ans, mid%(1000000007));
                }
                right = mid-1;
            }
           
        }
       return ans; 
    }
};


Arpit:
Solution 2nd question
class Solution {
public:
    int heightl(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->left;
      }
        return h;
    }
     int heightr(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->right;
      }
        return h;
    }
    int countNodes(TreeNode* root) {
        if(root==NULL)
            return 0;
        int l=heightl(root);
        int r=heightr(root);
        if(l==r){
          return pow(2,l)-1;
        }
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

Solution 3rd question
class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
        
        map<string,pair<TreeNode*,int>>m;
            int num=0;string v="";
        TreeNode* z=NULL;int x;
        TreeNode* root=NULL;
        for(int i=0;i<s.length();i++){
            if(s[i]>=48 && s[i]<=57){
                 num=0;
                while(i<s.length() && s[i]>=48 && s[i]<=57){
                    num=num*10+(s[i]-48);
                    i++;
                }
                i--;
                  z=new TreeNode(num);
                if(root==NULL)
                    root=z;
                else{
                  root=m[v].first;
                  x=m[v].second;
                    if(x==0){
                        root->left=z;
                    }
                    if(x==1){
                        root->right=z;
                    }
                }
            }
            else{
               int l=v.length();
                 v="";
               while(s[i]=='-'){
                   v.push_back('-');
                   i++;
               }
               int u=v.length();
                i--;
                if(m.find(v)==m.end()){
                    m[v]={z,0};
                }
                else if(m.find(v)!=m.end() && m[v].second!=1){
                    m[v].second++;
                }
                else{
                    m[v]={z,0};
                }
                if(l>u){
                for(auto it=++m.find(v);it!=m.end();it++){
                    (*it).second.second=1;
                }
                }
            }
        }
        if(m.size()==0){
            return z;
        }
        auto pair=m["-"];
        return pair.first;
    }
};



Gajendra:
1st ques:
class Solution {
public:
    
    
    bool condition(long long int mid,long long int req,long long int a,long long int b,long long lcm)
    {
        long long int posx=mid/a+mid/b-(mid/lcm);
        if(posx<req)
            return false;
        return true;
    }
    
    int nthMagicalNumber(int n, int a, int b) {
        long long int gcd=__gcd(a,b);
        long long int lcm=a*b/gcd;
       long long int left=1,right=1e18;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            if(condition(mid,n,a,b,lcm))
                right=mid;
            else
                left=mid+1;
        }
        int mod=1e9+7;
        return left%mod;
    }
};

2nd ques:
class Solution {
public:
    int lheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+lheight(root->left);
    }
    
    int rheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+rheight(root->right);
    }
    int countNodes(TreeNode* root) {
      
        if(!root)return 0;
        
        int l=lheight(root->left);
        int r=rheight(root->right);

        
        if(l==r)
            return pow(2,l+1)-1;
        
        cout<<l<<" "<<r<<endl;
        
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

3rd question:


class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
     
        map<int,TreeNode*> m;
        int current_level=0,chk=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]=='-')
                current_level++;
            else
            {
                string num;
                while(i<s.size()&&s[i]>='0'&&s[i]<='9')
                {
                    num.push_back(s[i]);
                    i++;
                }
                
                i--;
                
                stringstream ss;
                ss<<num;
                int n;
                ss>>n;
                
                TreeNode* temp=new TreeNode(n);
                
                m[current_level]=temp;
                
                if(current_level){
                    
                if(m[current_level-1]->left)
                    m[current_level-1]->right=temp;
                else
                    m[current_level-1]->left=temp;
                }
                current_level=0;
            }
        }
        return m[0];
    }
};

-----------------------------------------------------------------------------

<<<<<<< HEAD
=======

>>>>>>> 220a8bba66c07ac446287a9879dd949553d41b73



Date:12/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/ugly-number-iii
Ashish->   https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
Karan-> https://leetcode.com/problems/letter-combinations-of-a-phone-number/

-------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

1st ques:
class Solution {
public:
    
    bool condition(long long int mid,long long int l1,long long int l2,long long int l3,long long int l4,long long int a,long long int b,long long int c,long long int req)
    {
        long long int n=mid/a+mid/b+mid/c-mid/l1-mid/l2-mid/l3+mid/l4;
        // cout<<mid<<" "<<n<<endl;
        if(n<req)
            return false;
        return true;
    }
    
    int nthUglyNumber(long long int n, long long int a, long long int b, long long int c) {
        long long int left=1,right=1e18;
        long long int lcm1=(a*b)/__gcd(a,b);
        long long int lcm2=(b*c)/__gcd(b,c);
        long long int lcm3=(a*c)/__gcd(a,c);
        long long int lcm4=a*lcm2/(__gcd(a,lcm2));
        // cout<<lcm1<<lcm2<<lcm3<<lcm4<<endl;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            // cout<<left<<" @ "<<right<<endl;
            if(condition(mid,lcm1,lcm2,lcm3,lcm4,a,b,c,n))
                right=mid;
            else
                left=mid+1;
        }
        return left;
        
    }
};

2nd ques:

class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& v, int startPos, int k) {
        unordered_map<int,int> m;
        for(auto i:v)m[i[0]]=i[1];
         int sum1=m[startPos];
        for(int i=startPos+1;i<=k+startPos;i++)
            sum1+=m[i];
         int res=sum1;
        int left=startPos-1,right=startPos+k;
        while(left>=0&&left<right)
        {
            res=max(res,sum1);
            sum1-=m[right];
            right--;
            sum1-=m[right];
            right--;
            sum1+=m[left];
            left--;
        }
            res=max(res,sum1);
            sum1=m[startPos],left=startPos-k,right=startPos+1;
            for(int i=startPos-1;i>=startPos-k;i--)
               sum1+=m[i];
        
          while(right<=v.back()[0]&&left<right)
           {
               res=max(res,sum1);
               sum1-=m[left];
               left++;
               sum1-=m[left];
               left++;
               sum1+=m[right];
               right++;
           }
            res=max(res,sum1);
        return res;
        
    }
};
Arpit
solution 1st question:-
class Solution {
public:
 int nthUglyNumber(int n, int a, int b, int c) {
       int start=1;
        int end=a*n;
        long int ab=(long int)a*b/gcd(a,b);
      long  int bc=(long int)c*b/gcd(c,b);
        long int ca=(long int)a*c/gcd(a,c);
         long int abc=(long int)a*bc/gcd(a,bc);
        while(start<end){
            int mid=start+(end-start)/2;
           int total=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ca+mid/abc;
           cout<<total<<" ";
            if(total<n){
                start=mid+1;
            }
            else
                end=mid;
        }
        return end;
    }
};
solution 3rd question:-
class Solution {
public:
     vector<string> v={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    
    vector<string> lc(string s){
          vector<string>m;
        if(s.length()==0){
            m.push_back(""); 
            return m;
        }
        char ch=s[0];
        string sub=s.substr(1);
         m=lc(sub);
        vector<string>res;
        string rstr=v[ch-'0'];
        for(int i=0;i<rstr.length();i++){
            char cha =rstr[i];
            for(string c:m){
                res.push_back(cha+c);
            }
        }
        return res;
    }
    
    vector<string> letterCombinations(string s) {
        vector<string> res;
        if(s.size()==0) return res;
         res=lc(s);
        return res;
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------


<<<<<<< HEAD
Ashish->
https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
=======

Date:13/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/partition-equal-subset-sum/
Arpit -> https://leetcode.com/problems/path-sum-iii/
Ashish -> https://leetcode.com/problems/zigzag-conversion/
Karan -> https://leetcode.com/problems/construct-string-from-binary-tree/
------------------------------------------------------------------------------------------------------------------------------------------------------------

Solutions:

From Gajendra:
1st: 
class Solution {
public:
        struct HASH{
	size_t operator()(const pair<int,int> &x)const{
		return hash<int>()(x.first^x.second);
	}
};
    unordered_map<pair<int,int>,int,HASH> m;
    bool can(int sum,vector<int>&v,int i,int req)
    {
        if(i>=v.size())
            return false;
        if(sum==req)
            return true;
        if(sum>req)
            return false;
        
        if(m.find({i,sum})!=m.end())
            return m[{i,sum}];
        
        return m[{i,sum}]=can(sum+v[i],v,i+1,req)||can(sum,v,i+1,req);
    }
    
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(auto i:nums)sum+=i;
        if(sum%2==0)
        {
            sum/=2;
            if(can(0,nums   ,0,sum))
                return true;
        }            
        return false;
    }
};
2nd:
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1)
            return s;
        bool decreasing=false;
        vector<vector<char>>v;
        for(int i=0;i<numRows;i++)
        {
            vector<char> temp;
            for(int j=0;j<s.length();j++)
            {
              temp.push_back(' ');  
            }
            v.push_back(temp);
        }
        int row=0,col=0;
        for(auto i:s)
        {
            if(decreasing)
            {
                col++;
                v[row][col]=i;
                row--;
                if(row<=0)
                {decreasing=false;row=0;col++;}
            }
            else
            {
                v[row][col]=i;
                if(row==numRows-1)
                {
                    decreasing=true;row--;
                }
                else
                    row++;
                if(row==0)
                {
                    decreasing=false;col++;
                }
            }
        }
        string res;
        for(auto i:v)
        {
            for(auto j:i)
            {
                // cout<<j<<" ";
                if(j!=' ')
                res.push_back(j);
            }
            // cout<<endl;
        }
        return res;
    }
};
3rd:


class Solution {
public:
    
    void solve(TreeNode* root,int targetSum,map<int,int> m,int &res,int currSum)
    {
        if(root==NULL)
            return;
        currSum+=root->val;
        
        int req=currSum-targetSum;
        
        if(m.find(req)!=m.end())
            res+=m[req];
        
        m[currSum]++;
        
        solve(root->left,targetSum,m,res,currSum);
        solve(root->right,targetSum,m,res,currSum);
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        int res=0;
        map<int,int> m;
        m[0]=1;
        solve(root,targetSum,m,res,0);
        return res;
    }
};


4th:

class Solution {
public:
    void t(TreeNode* r,string &res)
    {
        if(!r)
            return;

        stringstream ss;
        ss<<r->val;
        string num;ss>>num;
        
        res+=num;
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back('(');
        
        t(r->left,res);     
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back(')');
        
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back('(');

        t(r->right,res); 
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back(')');
        
    }
    
    string tree2str(TreeNode* root) {
        string res;
        t(root,res);
        return res;
        
    }
};



Arpit's
solution ques2:-
class Solution {
public:
    int ct=0;
    int p=1;
    void func(TreeNode* root,int s){
        if(root==NULL) return ;
        if(root->val==s){ ct++;}
        func(root->left,s-root->val);
        func(root->right,s-root->val);
    }
    void helper(TreeNode* root,int targetSum){
        if(root==NULL) return;
         func(root->left,targetSum);
         func(root->right,targetSum);
        helper(root->left,targetSum);
        helper(root->right,targetSum);        
    }
    int pathSum(TreeNode* root, int targetSum) {
       if(root==NULL) return 0;
        if(p) {
             func(root,targetSum);
            p=0;
        }
       helper(root,targetSum);
        return ct;
    }
};






From Ashish
gajendra que's soln
bool check(vector<int>&nums, int sum, int n,vector<vector<int>>&dp){
    if(sum<0){
        return false;
    }
    if(sum==0){
        return true;
    }
    if(n==0){
        return false;
    }
    if(dp[sum][n]!=-1){
        return dp[sum][n];
    }
    bool x = check(nums, sum-nums[n-1],n-1,dp);
    bool y = check(nums, sum, n-1,dp);
    dp[sum][n] = (x|y);
    return dp[sum][n];
    
}

class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto x: nums){
            sum+=x;
        }
        if(sum&1){
            return false;
        }
        sum/=2;
        
        vector<int>dpp(nums.size()+1,-1);
        vector<vector<int>> dp(sum+1,dpp);
        return check(nums,sum,nums.size(),dp);
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------



Date: 14/12/2021

Questions:
Gajendra-> https://leetcode.com/problems/range-sum-of-bst/
Arpit-> https://leetcode.com/problems/delete-node-in-a-bst/
Karan -> https://leetcode.com/problems/my-calendar-i/
Ashish-> https://leetcode.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/


---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra
1st :
class Solution {
public:
    int res=0;
    void traverse(TreeNode* r,int low,int high)
    {
        if(r==NULL)
            return;
        if(r->val>=low&&r->val<=high)
            res+=r->val;
        if(r->val>=low&&r->val<=high)
        {
            traverse(r->left,low,high);
            traverse(r->right,low,high);
        }
        else if(r->val<low)
            traverse(r->right,low,high);
        else if(r->val>high)
            traverse(r->left,low,high);

    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        traverse(root,low,high);
        return res;
    }
};

2nd:
class Solution {
public:
    TreeNode* findMin(TreeNode* r)
    {
        while(r->left!=NULL)    
            r=r->left;
        return r;
    }
    void del_node(TreeNode* &r,TreeNode*  d)
    {
        if(r==NULL)return;
        if(r->left==d)
        {
            
            r->left=r->left->right;
            return;
        }
      if(r->right==d)
        {
            r->right=r->right->right;
            return;
        }
        del_node(r->left,d);
        del_node(r->right,d);
        
    }
    void dn(TreeNode* &r,int k,TreeNode* tab)
    {
        if(r==NULL)
            return;
        
        if(r->val==k)
        {
            if(r->left==NULL&&r->right==NULL)
            {
              //leaf node
                // del_node(tab,r);
                r=r->right;
                return;
            }
            else if(r->right==NULL&&r->left!=NULL)
            {
                r=r->left;
                return;
            }
            TreeNode* temp=(findMin(r->right));
            cout<<temp->val;
            TreeNode* gp=temp;
            del_node(r,temp);
            r->val=gp->val;
            return;
        }
        dn(r->left,k,tab);
        dn(r->right,k,tab);
        
    }
    
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if(root==NULL)
            return root;
        
        if(root->val==key&&root->left==NULL&&root->right==NULL)
            return NULL;

        dn(root,key,root);
        
        return root;
        
    }
};
3rd:
class MyCalendar {
    map<int, int>bookings;
public:    
    bool book(int s1, int e1) {
        
        for(auto  i: bookings) 
        {
            int s2=i.first;
            int e2=i.second;
            if( s1 < e2 && s2 < e1 )   
			    return false; 
        }
        bookings[s1] = e1;                
        return true;
    }
};




Arpit's solution 2nd question:-
class Solution {
public:
    TreeNode* minvalright(TreeNode* root){
        while(root->left){
            root=root->left;
        }
        return root;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return root;
        if(key<root->val){
            root->left=deleteNode(root->left,key);
        }
        else if(key>root->val){
            root->right=deleteNode(root->right,key);
        }
        else{
            TreeNode* temp=NULL;
            if(root->left==NULL){
                temp=root->right;
                delete root;
                return temp;
            }
            else if(root->right==NULL){
                temp=root->left;
                delete root;
                return temp;
            }
            else{
             temp=minvalright(root->right);
            root->val=temp->val;
            root->right=deleteNode(root->right,temp->val);
            }
        }
        return root;
    }
};


-----------------------
Ashish : Gajendra que soln:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
void finder(TreeNode* root, int &sum,int low, int max){
    
    if(root==NULL){return;}
    if(root->val>=low && root->val<=max){
        sum+=root->val;
    }
    if(root->val>=max){
       finder(root->left,sum,low,max); 
    }
    else if(root->val<=low){
        finder(root->right,sum,low,max);
    }
   
   else{
       finder(root->left,sum,low,max);
       finder(root->right,sum,low,max);
   }
    
    
}
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int sum = 0;
        finder(root,sum,low,high);
        return sum;
    }
};


ASHISH : arpit's que
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    int minFinder(TreeNode* root){
       
        int tt = root->val;
        while(root){
            tt = min(tt,root->val);
            root = root->left;
        }
        return tt;
    }
    TreeNode* deleteNode(TreeNode* &root, int key) {
        if(root==NULL){return NULL;}
        if(root->val==key && root->right==NULL){
            return root->left;
        }
        if(root->val==key && root->left==NULL){
            return root->right;
        }
        if(root->val==key){
            int pending = minFinder(root->right);
            root->val = pending;
            root->right = deleteNode(root->right,pending);
            return root;
        }
        
        if(root->val>key){
            root->left = deleteNode(root->left,key);
            return root;
        }
          root->right = deleteNode(root->right,key);
          return root;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------
<<<<<<< HEAD


Date: 15/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/insertion-sort-list/
Karan -> https://leetcode.com/problems/fraction-to-recurring-decimal/

ASHISH: 
https://leetcode.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/

<<<<<<< HEAD



OLD QUE  OF KARAN
my calender 1 soln from ashish

class MyCalendar {
public:
    // just a map to take care of interval of prev books
    map<int,int> track;
    MyCalendar() {
        
    }
    
//     try to understand this concept like if there are two intervals like   7----->10  and 2--------->10 so its beneficial to take 2-----> 10 in track map since 7 lies between them so track map has key as ending of event and value as minimum time of beginnig of event 
    
    
    
    
    bool book(int start, int end) {
        end--;
        for(auto x: track){
            if(x.first>=start){
//                checking any interval found with which given slot is overlapping or not 
                    if(x.second<=end){
                        return false;
                    }
                
            }
        }
        
        // here we are checking ending time is already in track map in that case we will just try to minimise the beginning time 
        if(track.find(end)!=track.end()){
            track[end] = min(start,track[end]);
        }
        else{
            track[end] = start;
        }
        return true;
        
        
    }
};

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */






Date: 17/12/2021

Questions: 

Gajendra -> https://leetcode.com/problems/maximal-square/
Karan -> https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/