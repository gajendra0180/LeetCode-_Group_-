Date:10/12/2021
Gajendra -https://leetcode.com/problems/merge-intervals/
Gajendra- https://leetcode.com/problems/sort-colors/submissions/
Karan -https://leetcode.com/problems/longest-substring-without-repeating-characters/
ASHISH - https://leetcode.com/problems/next-permutation/

----------------------------------------------------------


//ASHISH
//first soln
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& v) {
        if(v.size()==1){return v;}
      sort(v.begin(),v.end());
        vector<vector<int>> ans;
        ans.push_back(v[0]);
        for(int i = 1; i<v.size(); i++){
            
            if(ans.back()[1]<v[i][0]){
                ans.push_back({v[i][0],v[i][1]});
            }
            else{
                int new_first = ans.back()[0];
                int new_second = max(ans.back()[1],v[i][1]);
                ans.pop_back();
                ans.push_back({new_first,new_second});
            }
            
            
        }
        return ans;
    }
};

//2nd soln

class Solution {
public:
    void sortColors(vector<int>& nums) {
    int zero = 0;
    int one = 0;
    int two = 0;
    for(auto x: nums){
        if(x==0){zero++;}
        else if(x==1){one++;}
        else{two++;}
    }
    for(int i =0; i<nums.size(); i++){
        if(zero){
            nums[i] = 0;
            zero--;
        }
        else if(one){
            nums[i] = 1;
            one--;
        }
        else{
            nums[i] = 2;
            two--;
        }
    }

    }
};



//3rd solution

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       if(s.length()==0 || s.length()==1){
           return s.length();
       }
        
        map<char,int> store;
        for(int i =0; i<s.length();i++){
            store[s[i]] = i;
        }
       
     
        vector<int>ans;
        for(int i =0; i<s.length();i++){
            ans.push_back(0);
        }
        ans[s.length()-1] = 1;
        for(int i = s.length()-2;i>=0;i--){
            if(store[s[i]]>i){
                
             int xx = store[s[i]]-i;
             int yy = ans[i+1]+1;
                ans[i] = min(xx,yy);
                store[s[i]] = i;
            }
            else if(store[s[i]]<=i){
                ans[i]=ans[i+1]+1;
                
                 store[s[i]] = i;
                
            }
        }
        sort(ans.begin(),ans.end());
        return ans[ans.size()-1];
        
    }
};

-------------------------------------------------------------------




Dated: 11/12/2021


Questions:
Gajendra-https://leetcode.com/problems/nth-magical-number/
Arpit- https://leetcode.com/problems/count-complete-tree-nodes/submissions/
Karan - https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

Ashish-
https://leetcode.com/problems/swap-nodes-in-pairs/





Solutions:

----------------------------------------------------------------------------

Ashish:
my que soln:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
       if(head==NULL || head->next==NULL){
           return head;
       } 
        
        ListNode* pre = NULL;
        ListNode* pos = head;
        while(pos!=NULL){
            if(pre==NULL){
                 if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre = pos;
                head = mid;
                pos = st;
            }
            else{
                if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre->next = mid;
                pre = pos;
                pos = st;
                
            }
            
            
        }
        return head;
    }
};



Ashish : karan's que ans
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define tn TreeNode
class Solution {
public:
    TreeNode* recoverFromPreorder(string t) {
        
        int d = 0;
        int v = 0;
        map<tn*,int> map_dist;
        map<tn*,vector<int>> map_allow;
        tn* root = NULL;
        stack<tn*> myset;
    
        for(auto x: t){
          
            if(x!='-'){
                v = v*10+(x-'0');
                
              
               
             
            }
            else{
            
               if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                       continue;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
                
                
                d++;
                
                
                
            }
        }
        
        if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                      return root;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
        return root;
        
        
    }
};

ASHISH: Gajendra que ans
#define ll long long
ll gcd(ll a, ll b){
    if(a==0){return b;}
    if(b==0){return a;}
    return gcd(b, a%b);
}
ll lcm(ll a, ll b){
    return (a*b)/gcd(a,b);
}
class Solution {
public:
    int nthMagicalNumber(int nn, int a, int b) {
        ll aa = (ll)a;
        ll bb = (ll)b;
        ll n = nn;
        ll left = 1;
        ll k = lcm(aa,bb);
        ll right = 1e18;
        ll ans = 1e18;
        while(left<=right){
            ll mid = (left+right)/2;
            ll target = (mid/aa)+(mid/bb)-(mid/k);
            if(target<n){
                left = mid+1;
            }
            else{
                if(target==n){
                    ans = min(ans, mid%(1000000007));
                }
                right = mid-1;
            }
           
        }
       return ans; 
    }
};


Arpit:
Solution 2nd question
class Solution {
public:
    int heightl(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->left;
      }
        return h;
    }
     int heightr(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->right;
      }
        return h;
    }
    int countNodes(TreeNode* root) {
        if(root==NULL)
            return 0;
        int l=heightl(root);
        int r=heightr(root);
        if(l==r){
          return pow(2,l)-1;
        }
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

Solution 3rd question
class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
        
        map<string,pair<TreeNode*,int>>m;
            int num=0;string v="";
        TreeNode* z=NULL;int x;
        TreeNode* root=NULL;
        for(int i=0;i<s.length();i++){
            if(s[i]>=48 && s[i]<=57){
                 num=0;
                while(i<s.length() && s[i]>=48 && s[i]<=57){
                    num=num*10+(s[i]-48);
                    i++;
                }
                i--;
                  z=new TreeNode(num);
                if(root==NULL)
                    root=z;
                else{
                  root=m[v].first;
                  x=m[v].second;
                    if(x==0){
                        root->left=z;
                    }
                    if(x==1){
                        root->right=z;
                    }
                }
            }
            else{
               int l=v.length();
                 v="";
               while(s[i]=='-'){
                   v.push_back('-');
                   i++;
               }
               int u=v.length();
                i--;
                if(m.find(v)==m.end()){
                    m[v]={z,0};
                }
                else if(m.find(v)!=m.end() && m[v].second!=1){
                    m[v].second++;
                }
                else{
                    m[v]={z,0};
                }
                if(l>u){
                for(auto it=++m.find(v);it!=m.end();it++){
                    (*it).second.second=1;
                }
                }
            }
        }
        if(m.size()==0){
            return z;
        }
        auto pair=m["-"];
        return pair.first;
    }
};



Gajendra:
1st ques:
class Solution {
public:
    
    
    bool condition(long long int mid,long long int req,long long int a,long long int b,long long lcm)
    {
        long long int posx=mid/a+mid/b-(mid/lcm);
        if(posx<req)
            return false;
        return true;
    }
    
    int nthMagicalNumber(int n, int a, int b) {
        long long int gcd=__gcd(a,b);
        long long int lcm=a*b/gcd;
       long long int left=1,right=1e18;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            if(condition(mid,n,a,b,lcm))
                right=mid;
            else
                left=mid+1;
        }
        int mod=1e9+7;
        return left%mod;
    }
};

2nd ques:
class Solution {
public:
    int lheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+lheight(root->left);
    }
    
    int rheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+rheight(root->right);
    }
    int countNodes(TreeNode* root) {
      
        if(!root)return 0;
        
        int l=lheight(root->left);
        int r=rheight(root->right);

        
        if(l==r)
            return pow(2,l+1)-1;
        
        cout<<l<<" "<<r<<endl;
        
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

3rd question:


class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
     
        map<int,TreeNode*> m;
        int current_level=0,chk=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]=='-')
                current_level++;
            else
            {
                string num;
                while(i<s.size()&&s[i]>='0'&&s[i]<='9')
                {
                    num.push_back(s[i]);
                    i++;
                }
                
                i--;
                
                stringstream ss;
                ss<<num;
                int n;
                ss>>n;
                
                TreeNode* temp=new TreeNode(n);
                
                m[current_level]=temp;
                
                if(current_level){
                    
                if(m[current_level-1]->left)
                    m[current_level-1]->right=temp;
                else
                    m[current_level-1]->left=temp;
                }
                current_level=0;
            }
        }
        return m[0];
    }
};

-----------------------------------------------------------------------------

<<<<<<< HEAD
=======

>>>>>>> 220a8bba66c07ac446287a9879dd949553d41b73



Date:12/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/ugly-number-iii
Ashish->   https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
Karan-> https://leetcode.com/problems/letter-combinations-of-a-phone-number/

-------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

1st ques:
class Solution {
public:
    
    bool condition(long long int mid,long long int l1,long long int l2,long long int l3,long long int l4,long long int a,long long int b,long long int c,long long int req)
    {
        long long int n=mid/a+mid/b+mid/c-mid/l1-mid/l2-mid/l3+mid/l4;
        // cout<<mid<<" "<<n<<endl;
        if(n<req)
            return false;
        return true;
    }
    
    int nthUglyNumber(long long int n, long long int a, long long int b, long long int c) {
        long long int left=1,right=1e18;
        long long int lcm1=(a*b)/__gcd(a,b);
        long long int lcm2=(b*c)/__gcd(b,c);
        long long int lcm3=(a*c)/__gcd(a,c);
        long long int lcm4=a*lcm2/(__gcd(a,lcm2));
        // cout<<lcm1<<lcm2<<lcm3<<lcm4<<endl;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            // cout<<left<<" @ "<<right<<endl;
            if(condition(mid,lcm1,lcm2,lcm3,lcm4,a,b,c,n))
                right=mid;
            else
                left=mid+1;
        }
        return left;
        
    }
};

2nd ques:

class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& v, int startPos, int k) {
        unordered_map<int,int> m;
        for(auto i:v)m[i[0]]=i[1];
         int sum1=m[startPos];
        for(int i=startPos+1;i<=k+startPos;i++)
            sum1+=m[i];
         int res=sum1;
        int left=startPos-1,right=startPos+k;
        while(left>=0&&left<right)
        {
            res=max(res,sum1);
            sum1-=m[right];
            right--;
            sum1-=m[right];
            right--;
            sum1+=m[left];
            left--;
        }
            res=max(res,sum1);
            sum1=m[startPos],left=startPos-k,right=startPos+1;
            for(int i=startPos-1;i>=startPos-k;i--)
               sum1+=m[i];
        
          while(right<=v.back()[0]&&left<right)
           {
               res=max(res,sum1);
               sum1-=m[left];
               left++;
               sum1-=m[left];
               left++;
               sum1+=m[right];
               right++;
           }
            res=max(res,sum1);
        return res;
        
    }
};
Arpit
solution 1st question:-
class Solution {
public:
 int nthUglyNumber(int n, int a, int b, int c) {
       int start=1;
        int end=a*n;
        long int ab=(long int)a*b/gcd(a,b);
      long  int bc=(long int)c*b/gcd(c,b);
        long int ca=(long int)a*c/gcd(a,c);
         long int abc=(long int)a*bc/gcd(a,bc);
        while(start<end){
            int mid=start+(end-start)/2;
           int total=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ca+mid/abc;
           cout<<total<<" ";
            if(total<n){
                start=mid+1;
            }
            else
                end=mid;
        }
        return end;
    }
};
solution 3rd question:-
class Solution {
public:
     vector<string> v={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    
    vector<string> lc(string s){
          vector<string>m;
        if(s.length()==0){
            m.push_back(""); 
            return m;
        }
        char ch=s[0];
        string sub=s.substr(1);
         m=lc(sub);
        vector<string>res;
        string rstr=v[ch-'0'];
        for(int i=0;i<rstr.length();i++){
            char cha =rstr[i];
            for(string c:m){
                res.push_back(cha+c);
            }
        }
        return res;
    }
    
    vector<string> letterCombinations(string s) {
        vector<string> res;
        if(s.size()==0) return res;
         res=lc(s);
        return res;
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------


<<<<<<< HEAD
Ashish->
https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
=======

Date:13/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/partition-equal-subset-sum/
Arpit -> https://leetcode.com/problems/path-sum-iii/
Ashish -> https://leetcode.com/problems/zigzag-conversion/
Karan -> https://leetcode.com/problems/construct-string-from-binary-tree/
------------------------------------------------------------------------------------------------------------------------------------------------------------

Solutions:

From Gajendra:
1st: 
class Solution {
public:
        struct HASH{
	size_t operator()(const pair<int,int> &x)const{
		return hash<int>()(x.first^x.second);
	}
};
    unordered_map<pair<int,int>,int,HASH> m;
    bool can(int sum,vector<int>&v,int i,int req)
    {
        if(i>=v.size())
            return false;
        if(sum==req)
            return true;
        if(sum>req)
            return false;
        
        if(m.find({i,sum})!=m.end())
            return m[{i,sum}];
        
        return m[{i,sum}]=can(sum+v[i],v,i+1,req)||can(sum,v,i+1,req);
    }
    
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(auto i:nums)sum+=i;
        if(sum%2==0)
        {
            sum/=2;
            if(can(0,nums   ,0,sum))
                return true;
        }            
        return false;
    }
};
2nd:
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1)
            return s;
        bool decreasing=false;
        vector<vector<char>>v;
        for(int i=0;i<numRows;i++)
        {
            vector<char> temp;
            for(int j=0;j<s.length();j++)
            {
              temp.push_back(' ');  
            }
            v.push_back(temp);
        }
        int row=0,col=0;
        for(auto i:s)
        {
            if(decreasing)
            {
                col++;
                v[row][col]=i;
                row--;
                if(row<=0)
                {decreasing=false;row=0;col++;}
            }
            else
            {
                v[row][col]=i;
                if(row==numRows-1)
                {
                    decreasing=true;row--;
                }
                else
                    row++;
                if(row==0)
                {
                    decreasing=false;col++;
                }
            }
        }
        string res;
        for(auto i:v)
        {
            for(auto j:i)
            {
                // cout<<j<<" ";
                if(j!=' ')
                res.push_back(j);
            }
            // cout<<endl;
        }
        return res;
    }
};
3rd:


class Solution {
public:
    
    void solve(TreeNode* root,int targetSum,map<int,int> m,int &res,int currSum)
    {
        if(root==NULL)
            return;
        currSum+=root->val;
        
        int req=currSum-targetSum;
        
        if(m.find(req)!=m.end())
            res+=m[req];
        
        m[currSum]++;
        
        solve(root->left,targetSum,m,res,currSum);
        solve(root->right,targetSum,m,res,currSum);
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        int res=0;
        map<int,int> m;
        m[0]=1;
        solve(root,targetSum,m,res,0);
        return res;
    }
};


4th:

class Solution {
public:
    void t(TreeNode* r,string &res)
    {
        if(!r)
            return;

        stringstream ss;
        ss<<r->val;
        string num;ss>>num;
        
        res+=num;
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back('(');
        
        t(r->left,res);     
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back(')');
        
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back('(');

        t(r->right,res); 
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back(')');
        
    }
    
    string tree2str(TreeNode* root) {
        string res;
        t(root,res);
        return res;
        
    }
};



Arpit's
solution ques2:-
class Solution {
public:
    int ct=0;
    int p=1;
    void func(TreeNode* root,int s){
        if(root==NULL) return ;
        if(root->val==s){ ct++;}
        func(root->left,s-root->val);
        func(root->right,s-root->val);
    }
    void helper(TreeNode* root,int targetSum){
        if(root==NULL) return;
         func(root->left,targetSum);
         func(root->right,targetSum);
        helper(root->left,targetSum);
        helper(root->right,targetSum);        
    }
    int pathSum(TreeNode* root, int targetSum) {
       if(root==NULL) return 0;
        if(p) {
             func(root,targetSum);
            p=0;
        }
       helper(root,targetSum);
        return ct;
    }
};






From Ashish
gajendra que's soln
bool check(vector<int>&nums, int sum, int n,vector<vector<int>>&dp){
    if(sum<0){
        return false;
    }
    if(sum==0){
        return true;
    }
    if(n==0){
        return false;
    }
    if(dp[sum][n]!=-1){
        return dp[sum][n];
    }
    bool x = check(nums, sum-nums[n-1],n-1,dp);
    bool y = check(nums, sum, n-1,dp);
    dp[sum][n] = (x|y);
    return dp[sum][n];
    
}

class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto x: nums){
            sum+=x;
        }
        if(sum&1){
            return false;
        }
        sum/=2;
        
        vector<int>dpp(nums.size()+1,-1);
        vector<vector<int>> dp(sum+1,dpp);
        return check(nums,sum,nums.size(),dp);
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------



Date: 14/12/2021

Questions:
Gajendra-> https://leetcode.com/problems/range-sum-of-bst/
Arpit-> https://leetcode.com/problems/delete-node-in-a-bst/
Karan -> https://leetcode.com/problems/my-calendar-i/
Ashish-> https://leetcode.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/


---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra
1st :
class Solution {
public:
    int res=0;
    void traverse(TreeNode* r,int low,int high)
    {
        if(r==NULL)
            return;
        if(r->val>=low&&r->val<=high)
            res+=r->val;
        if(r->val>=low&&r->val<=high)
        {
            traverse(r->left,low,high);
            traverse(r->right,low,high);
        }
        else if(r->val<low)
            traverse(r->right,low,high);
        else if(r->val>high)
            traverse(r->left,low,high);

    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        traverse(root,low,high);
        return res;
    }
};

2nd:
class Solution {
public:
    TreeNode* findMin(TreeNode* r)
    {
        while(r->left!=NULL)    
            r=r->left;
        return r;
    }
    void del_node(TreeNode* &r,TreeNode*  d)
    {
        if(r==NULL)return;
        if(r->left==d)
        {
            
            r->left=r->left->right;
            return;
        }
      if(r->right==d)
        {
            r->right=r->right->right;
            return;
        }
        del_node(r->left,d);
        del_node(r->right,d);
        
    }
    void dn(TreeNode* &r,int k,TreeNode* tab)
    {
        if(r==NULL)
            return;
        
        if(r->val==k)
        {
            if(r->left==NULL&&r->right==NULL)
            {
              //leaf node
                // del_node(tab,r);
                r=r->right;
                return;
            }
            else if(r->right==NULL&&r->left!=NULL)
            {
                r=r->left;
                return;
            }
            TreeNode* temp=(findMin(r->right));
            cout<<temp->val;
            TreeNode* gp=temp;
            del_node(r,temp);
            r->val=gp->val;
            return;
        }
        dn(r->left,k,tab);
        dn(r->right,k,tab);
        
    }
    
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if(root==NULL)
            return root;
        
        if(root->val==key&&root->left==NULL&&root->right==NULL)
            return NULL;

        dn(root,key,root);
        
        return root;
        
    }
};
3rd:
class MyCalendar {
    map<int, int>bookings;
public:    
    bool book(int s1, int e1) {
        
        for(auto  i: bookings) 
        {
            int s2=i.first;
            int e2=i.second;
            if( s1 < e2 && s2 < e1 )   
			    return false; 
        }
        bookings[s1] = e1;                
        return true;
    }
};




Arpit's solution 2nd question:-
class Solution {
public:
    TreeNode* minvalright(TreeNode* root){
        while(root->left){
            root=root->left;
        }
        return root;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return root;
        if(key<root->val){
            root->left=deleteNode(root->left,key);
        }
        else if(key>root->val){
            root->right=deleteNode(root->right,key);
        }
        else{
            TreeNode* temp=NULL;
            if(root->left==NULL){
                temp=root->right;
                delete root;
                return temp;
            }
            else if(root->right==NULL){
                temp=root->left;
                delete root;
                return temp;
            }
            else{
             temp=minvalright(root->right);
            root->val=temp->val;
            root->right=deleteNode(root->right,temp->val);
            }
        }
        return root;
    }
};


-----------------------
Ashish : Gajendra que soln:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
void finder(TreeNode* root, int &sum,int low, int max){
    
    if(root==NULL){return;}
    if(root->val>=low && root->val<=max){
        sum+=root->val;
    }
    if(root->val>=max){
       finder(root->left,sum,low,max); 
    }
    else if(root->val<=low){
        finder(root->right,sum,low,max);
    }
   
   else{
       finder(root->left,sum,low,max);
       finder(root->right,sum,low,max);
   }
    
    
}
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int sum = 0;
        finder(root,sum,low,high);
        return sum;
    }
};


ASHISH : arpit's que
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    int minFinder(TreeNode* root){
       
        int tt = root->val;
        while(root){
            tt = min(tt,root->val);
            root = root->left;
        }
        return tt;
    }
    TreeNode* deleteNode(TreeNode* &root, int key) {
        if(root==NULL){return NULL;}
        if(root->val==key && root->right==NULL){
            return root->left;
        }
        if(root->val==key && root->left==NULL){
            return root->right;
        }
        if(root->val==key){
            int pending = minFinder(root->right);
            root->val = pending;
            root->right = deleteNode(root->right,pending);
            return root;
        }
        
        if(root->val>key){
            root->left = deleteNode(root->left,key);
            return root;
        }
          root->right = deleteNode(root->right,key);
          return root;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------
<<<<<<< HEAD


Date: 15/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/insertion-sort-list/
Karan -> https://leetcode.com/problems/fraction-to-recurring-decimal/

ASHISH: 
https://leetcode.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/

<<<<<<< HEAD



OLD QUE  OF KARAN
my calender 1 soln from ashish

class MyCalendar {
public:
    // just a map to take care of interval of prev books
    map<int,int> track;
    MyCalendar() {
        
    }
    
//     try to understand this concept like if there are two intervals like   7----->10  and 2--------->10 so its beneficial to take 2-----> 10 in track map since 7 lies between them so track map has key as ending of event and value as minimum time of beginnig of event 
    
    
    
    
    bool book(int start, int end) {
        end--;
        for(auto x: track){
            if(x.first>=start){
//                checking any interval found with which given slot is overlapping or not 
                    if(x.second<=end){
                        return false;
                    }
                
            }
        }
        
        // here we are checking ending time is already in track map in that case we will just try to minimise the beginning time 
        if(track.find(end)!=track.end()){
            track[end] = min(start,track[end]);
        }
        else{
            track[end] = start;
        }
        return true;
        
        
    }
};

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */






Date: 17/12/2021

Questions: 

Gajendra -> https://leetcode.com/problems/maximal-square/
Karan -> https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
<<<<<<< HEAD
=======


------------------------------------------------------------------------------------------------------------------------------------------

Solution:

2nd ques(Karan):
class Solution {
public:
    int minAddToMakeValid(string s) {
        int gp=0,res=0;
        for(auto i:s)
        {
            if(i=='(')
                gp++;
            else
            {
               
                if(gp<=0)
                    res++;
                else
                     gp--;
            }
        }
        return res+gp;
    }
};

------------------------------------------------------------------------------------------------------------------------------------------


18 dec 

questions:

ASHISH -> https://leetcode.com/problems/container-with-most-water/


------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Gajendra
1st quest:
class Solution {
public:
    int maxArea(vector<int>& v) {
        int left=0,right=v.size()-1;
        int maxx=0;
        while(left<=right)
        {
            int quantity=(right-left)*(min(v[left],v[right]));
            if(v[left]<=v[right])
                left++;
            else

                right--;
            maxx=max(quantity,maxx);
        }
        return maxx;
    }
};


_------------------------------------------------------------------------------------------------------------------------------------------------




Date:19/12/2021

Questions:
Gajendra-> https://leetcode.com/contest/weekly-contest-272/problems/minimum-operations-to-make-the-array-k-increasing/
	  Hints: b)  https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
		 a)  https://www.geeksforgeeks.org/convert-to-strictly-increasing-integer-array-with-minimum-changes/
------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:
1)
class Solution {
public:
  
int CeilIndex(vector<int>& v, int l, int r, int key)
{
    return upper_bound(v.begin(),v.begin()+r,key)-v.begin();
}
 
int lis(vector<int>& v)
{
    if (v.size() == 0)
        return 0;
 
    vector<int> tail(v.size(), 0);
    int length = 1; // always points empty slot in tail
 
    tail[0] = v[0];
    for (size_t i = 1; i < v.size(); i++) {
 
        // new smallest value
        if (v[i] < tail[0])
            tail[0] = v[i];
 
        else if (v[i] >= tail[length - 1])
            tail[length++] = v[i];
 
        else
            tail[CeilIndex(tail, 0, length - 1, v[i])] = v[i];
    }
 
    return length;
}
    
    int kIncreasing(vector<int>& arr, int k) {
     
        int n=arr.size(),res=0;
        for(int i=0;i<k;i++)
        {
            vector<int> v;
            for(int j=i;j<n;j+=k)
                v.push_back(arr[j]);
            res+=v.size()-lis(v);
        }
        return res;
        
    }
};

----------------------------------------------------------------------------------------------------------------------------------------------


Date:20/12/2021

Questions:

Gajendra->https://leetcode.com/problems/decode-string/
Ashish -> https://leetcode.com/problems/3sum-closest/description/
Karan -> https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/
---------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra:
1) 
class Solution {
public:
    string tmp(string s,int &i)
    {
        string res="";
        if(i>=s.length())
            return res;
        while(i<s.length())
        {
            if(isalpha(s[i]))
               res.push_back(s[i]);
             else if(s[i]==']')
               return res;
              else if(isdigit(s[i]))
               {
                   string num="";
                   while(isdigit(s[i]))
                       num.push_back(s[i++]);
                   stringstream ss;
                   ss<<num;int n;ss>>n;
                   string ans=tmp(s,++i);
                   for(int j=0;j<n;j++)
                       res+=ans;
                  cout<<ans<< n <<res<<endl;
               }
               i++;
        }
        return res;
    }
    string decodeString(string s) {
        int i=0;
        return tmp(s,i);
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------
Date : 21/12/2021

Questions:

Karan-> https://leetcode.com/problems/power-of-two/
Gajendra -> https://leetcode.com/problems/merge-intervals/


---------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter: karan

class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n>0?!(n&(n-1)):false;
    }
};

Setter: Gajendra

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
       sort(intervals.begin(),intervals.end());
        vector<vector<int>>res;
        res.push_back({intervals[0][0],intervals[0][1]});
        for(int i=1;i<intervals.size();i++)
        {
            if(res.back()[1]>=intervals[i][0])
                res.back()[1]=max(res.back()[1],intervals[i][1]);
            else
                res.push_back({intervals[i][0],intervals[i][1]});
        }
        return res;
    }
};

Solver: Gajendra
Setter: Ashish
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> res{nums[0]};
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>res.back())
                res.push_back(nums[i]);
            else
            {
                auto ind=lower_bound(res.begin(),res.end(),nums[i])-res.begin();
                res[ind]=nums[i];
            }
        }
        return res.size();
    }
    
};


-----------------------------------------------------------------------------------------------------------------------------------------------------


Questions from Ashish:
https://leetcode.com/problems/longest-increasing-subsequence/

------------------------------------------------------------------------





Date : 22/12/2021

Questions:

Gajendra-> https://leetcode.com/problems/design-hashmap/submissions/ 
Karan -> https://leetcode.com/problems/reorder-list/submissions/



----------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra

class MyHashMap {
public:
    int arr[1000001];
    MyHashMap() {
    for(int i=0;i<1000001;i++)
      arr[i]=-1;
    }
    
    void put(int key, int value) {
        arr[key]=value;
    }
    
    int get(int key) {
        return arr[key];
    }
    
    void remove(int key) {
        arr[key]=-1;
    }
};


-----------------------------------------------------------------------------------------------------------------------------------------------------

ASHISH's que :

https://leetcode.com/problems/group-anagrams/submissions/


SOLVER : ASHISH
SETTER : ASHISH

class Solution {
public:
  // map for storing value as arr of  strings which is anagrams of key 
  map<string,vector<string>> str_store; 
    
//  here making  a function that takes string s in addition to str_store(defined above)
//     it will make a copy of string s as t after that it will sort that then just map....
void  checker(map<string,vector<string>> &str_store,string s){
    string t = s;
    sort(t.begin(),t.end());
   str_store[t].push_back(s);  
}
       
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
//         iterating over all strings  and then  appling checker function (explained above)
        for(auto x: strs){
            checker(str_store,x);
        }
// now returning vector of vector  as answer
        vector<vector<string>> ans;
        for(auto x: str_store){
            ans.push_back(x.second);
        }
        
        
        return ans;
    }
};




QUE FROM ASHISH
https://leetcode.com/problems/course-schedule-ii/
Solution from Gajendra for course-schedule-ii:
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& v) {
            map<int, vector<int>> g;
            map<int, int> indegree;
        for(auto i:v)
        {
            indegree[i[0]]++;
            g[i[1]].push_back(i[0]);
        }
        vector<int> res;
        int vis_count = 0;
        deque<int> dq;
        for (int i = 0; i <numCourses; i++)
            if (indegree[i] == 0)
                dq.push_back(i);
        while (dq.size())
        {
            auto u = dq.front();
            dq.pop_front();
            cout<<u;
            res.push_back(u);
            vis_count++;
            for (auto v : g[u])
            {
                indegree[v]--;
                if (indegree[v] == 0)
                    dq.push_back(v);
            }
        }
        if(vis_count!=numCourses)
            return {};
        return res;
    }
};







Date : 24/12/2021

Questions :

Karan -> https://leetcode.com/problems/min-stack/
Gajendra -> https://leetcode.com/problems/palindromic-substrings/
ASHISH -> https://leetcode.com/problems/integer-to-roman/submissions/




--------------------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra

class Solution {
public:
    int countSubstrings(string s) {
        int res=0;
        for(int i=0;i<s.length();i++)
        {
            int left=i-1,right=i+1;
            res++;
            while(left>=0&&right<s.length()&&s[left--]==s[right++])res++;
            left=i,right=i+1;
            while(left>=0&&right<s.length()&&s[left--]==s[right++])res++;
        }
        return res;
    }
};

Solver:Gajendra
Setter:Karan

class MinStack:
    
    def __init__(self):
        self.stack=[]
        self.minn=2**31+1

    def push(self, val: int) -> None:
        self.minn=min(self.minn,val)
        self.stack.append((val,self.minn))

    def pop(self) -> None:
        self.stack.pop()
        if len(self.stack)==0:
            self.minn=2**31+1
        else:
            self.minn=self.stack[-1][1]

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]
	
	
Solver:Arpit
Setter:Aashish
class Solution {
public:
    string intToRoman(int num) {
    string M[] = {"", "M", "MM", "MMM"};
    string C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    string X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    string I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
    }
};

---------------------------------------------------------------------------------------------------------------------------------------------------------------


Date:25/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/course-schedule/
Arpit -> https://leetcode.com/problems/regular-expression-matching/
Gajendra -> https://leetcode.com/problems/find-eventual-safe-states/submissions/
Karan -> https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver->Arpit
Setter->Arpit
class Solution {
public:
    bool isMatch(string s, string p) {
      if(p.length()==0){
          return s.length()==0;
      } 
      if(p.length()>1 && p[1]=='*'){
          if(isMatch(s,p.substr(2))){
              return true;
          }
          if(s.length()>0 && (s[0]==p[0] || p[0]=='.')){
             return isMatch(s.substr(1),p);
          }
          return false;
      }
        else{
            if(s.length()>0 && (s[0]==p[0] || p[0]=='.')){
               return isMatch(s.substr(1),p.substr(1));
            }
                return false; 
        }
        return true;
    }
};

Solver -> Gajendra
Setter ->Gajendra

class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& v) {
            map<int, vector<int>> g;
            map<int, int> indegree;
        for(auto i:v)
        {
            indegree[i[0]]++;
            g[i[1]].push_back(i[0]);
        }
        int vis_count = 0;
        deque<int> dq;
        for (int i = 0; i <numCourses; i++)
            if (indegree[i] == 0)
                dq.push_back(i);
        while (dq.size())
        {
            auto u = dq.front();
            dq.pop_front();
            cout<<u;
            vis_count++;
            for (auto v : g[u])
            {
                indegree[v]--;
                if (indegree[v] == 0)
                    dq.push_back(v);
            }
        }
        if(vis_count==numCourses)
            return true;
        return false;
    }
};

Setter -> Gajendra
Solver -> Gajendra

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
           map<int, vector<int>> g;
            map<int, int> indegree;
        
            for(int i=0;i<graph.size();i++)
            {
                for(auto j:graph[i])
                {
                    g[j].push_back(i);
                    indegree[i]++;
                }
            }
            vector<int> res;
            deque<int> dq;
            for (int i = 0; i <graph.size(); i++)
                if (indegree[i] == 0)
                    dq.push_back(i);
            while (dq.size())
            {
                auto u = dq.front();
                dq.pop_front();
                res.push_back(u);
                for (auto v : g[u])
                {
                    indegree[v]--;
                    if (indegree[v] == 0)
                        dq.push_back(v);
                }
            }
            sort(res.begin(),res.end());
            return res;
    }
};


---------------------------------------------------------------------------------------------------------------------------------------------------------------


Date: 26/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/recover-the-original-array/
Karan -> https://leetcode.com/problems/k-closest-points-to-origin/

--------------------------------------------------------------------------------------------------
Solutions:

Solver -> Gajendra
Setter ->Gajendra

class Solution {
public:
    vector<int> recoverArray(vector<int>& nums) {
        vector<int> k;
        sort(nums.begin(),nums.end());
        int child=nums[0];
        for(auto i:nums)
        {
            int x=i-child;
            if(x%2==0&&x!=0)
            k.push_back(x/2);
        }
        int res=0;
        for(auto kk:k)
        {
          unordered_map<int,int> m;
            for(auto i:nums)
                m[i]++;
            for(auto i:nums)
            {
                if(m.find(i)!=m.end())
                m[i]--;
                else
                continue;
               
                if(m.find(i+2*kk)!=m.end())
                    m[i+2*kk]--;
                else
                    break;
               if(m[i]==0)m.erase(i);
                if(m[i+2*kk]==0)
                    m.erase(i+2*kk);
            }
            if(m.size()==0)
            {
             res=kk;break;
            }
        }
        vector<int>result;
         unordered_map<int,int> m;
            for(auto i:nums)
                m[i]++;
             for(auto i:nums)
            {
             if(m.find(i)!=m.end())
             {m[i]--;result.push_back(i+res);}
                else
                continue;
                if(m[i]==0)m.erase(i);
                if(m.find(i+2*res)!=m.end())
                    m[i+2*res]--;
                else
                    continue;
                if(m[i+2*res]==0)
                    m.erase(i+2*res);
            }
        return result;
    }
};

Solver -> Gajendra
Setter -> Karan

class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        map<int,vector<vector<int>>> m;
        for(auto i:points)
        {
            int x=i[0],y=i[1];
            int gp=x*x+y*y;
            m[gp].push_back({x,y});
        }
        vector<vector<int>> res;
        for(auto i:m)
        {
            for(auto j:i.second)
            {
                k--;res.push_back({j[0],j[1]});
            }
            if(k==0)
                break;
        }
        return res;
    }
};


----------------------------------------------------------------------------------------------------



Date: 27/12/2021

Questions:

Gajendra -> https://leetcode.com/problems/basic-calculator-ii/
Karan -> https://leetcode.com/problems/number-complement/


Date: 28/12/2021
Questions:

Gajendra -> https://leetcode.com/problems/find-peak-element/      -> O(logn)
Karan -> https://leetcode.com/problems/middle-of-the-linked-list/



------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra
class Solution {
public:
    int findPeakElement(vector<int>& v) {

        int l=0,r=v.size()-1;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(v[mid]>v[mid+1])
                r=mid;
            else
                l=mid+1;
        }
        return l;
    }
};







------------------------------------------------------------------------



Today's question by ashish
https://leetcode.com/problems/surrounded-regions/submissions/




Soln for ashish que by ashish 



class Solution {
public:
    
  
void deadCatcher(int i , int j , vector<vector<char>> &board, set<vector<int>> &dead, set<vector<int>> &visited){
        
int row = board.size();
    
int col = board[0].size();
    
    
//     just a dfs to reach connected zero's position
    if(i>=row || i<0 || j>=col || j<0 || board[i][j]=='X'){return;}
    
    if(visited.find({i,j})!=visited.end()){return;}
    dead.insert({i,j});
    visited.insert({i,j});
    deadCatcher(i+1,j,board,dead,visited);
    deadCatcher(i-1,j,board,dead,visited);
    deadCatcher(i,j+1,board,dead,visited);
    deadCatcher(i,j-1,board,dead,visited);
  
        
        
    }
    
    void solve(vector<vector<char>>& board) {
        
//         hey hello ashish is here 
//         so direct soln is to  carry all zeroes which is on border or connected to any border zero whether through right, left, up, down direction so after carry all that zeroes's positions in suitable data-struct we have to just
//         iterate on all zeroes's position of given board and make that equal to 'X' only if that zero's postion  is not in that data-struct (in this soln i have used set of vector)
        

        
        
        
        
//         now i will be contuing with finding all that zeroes that are on border or...... for that purpose i will use dfs so visited set is for tell whether i am repeating or not 
//          see more in dfs fucntion named as deadCatcher 
        set<vector<int>> dead;
        set<vector<int>> visited;
        int row = board.size();
    int col = board[0].size();
        
        
        
        
//          begining dfs call to that position only which is already on border so that using dfs we can get all postiion which is connected to that
        for(int i =0; i<board.size(); i++){
            
            for(int j =0; j<board[0].size(); j++){
                if(board[i][j]=='O' && (i==0 || i==row-1 || j==0 || j==col-1)){
                    deadCatcher(i,j,board,dead,visited);
                }
            }
            
            
        }
        
        
        
//         after finding all zeroes'position which is connected to border zero we can apply our second step to flip that zero's position which is not in that set which is named as dead set
        
        
                for(int i =0; i<board.size(); i++){
            
            for(int j =0; j<board[0].size(); j++){
                if(board[i][j]=='O' && (dead.find({i,j})==dead.end())){
                    board[i][j] = 'X';
                }
            }
            
            
        }
        
      
        
        
    }
};


--------------------------------------------------------




1
Date: 29/12/2021

Questions:
Gajendra->https://leetcode.com/problems/3sum/
Karan -> https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
Ashish -> https://leetcode.com/problems/reverse-nodes-in-k-group/


------------------------------------------------------------------------------

Solutions:
Solver:Gajendra
Setter:Gajendra
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int a=0;a<nums.size();a++)
        {
            if(a>0&&nums[a]==nums[a-1])
                continue;
            int low=a+1,high=nums.size()-1;
            int req_sum=-nums[a];
            while(low<nums.size()-1&&high>0&&low<high)
            {
                int bPlusc=nums[low]+nums[high];
                if(bPlusc>-nums[a])
                {
                    high--;
                }
                else if(bPlusc<-nums[a])
                {
                    low++;
                }
                else if(bPlusc+nums[a]==0)
                {
                    res.push_back({nums[a],nums[low],nums[high]});
                    cout<<nums[a]<<" "<<nums[low]<<" "<<nums[high]<<endl;
                    low++;
                    while(low<nums.size()-1&&nums[low]==nums[low-1])
                        low++;
                    high--;
                    while(high>0&&nums[high]==nums[high+1])
                        high--;
                }
            }
        }
        return res;
    }
};

Solver:Gajendra
Setter:Karan
class FindElements {
public:

    map<int,bool>m;
    void traverse(int x,TreeNode* &root)
    {
        if(root==NULL)return;
        root->val=x;
        m[x]=true;
        traverse(2*x+1,root->left);
        traverse(2*x+2,root->right);
    }
    FindElements(TreeNode* root) {
        traverse(0,root);
    }
    
    bool find(int target) {
        return m[target];
    }
};



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


Date: 30/12/2021
Questions:
Gajendra -> https://leetcode.com/problems/interval-list-intersections/
Karan -> https://leetcode.com/problems/smallest-integer-divisible-by-k/
Arpit-> https://leetcode.com/problems/coin-change-2/
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
solver-Arpit
setter-Arpit
class Solution {
public:
    int dp[301][5001];
    int helper(vector<int>&coins,int amount,int n){
        if(n==0 || amount==0){
            return amount==0?1:0;
        }
        if(dp[n][amount]!=-1){
            return dp[n][amount];
        }
        if(coins[n-1]<=amount){
            return dp[n][amount]=(helper(coins,amount-coins[n-1],n)+helper(coins,amount,n-1));
        }
            return dp[n][amount]=helper(coins,amount,n-1);
    }
    int change(int amount, vector<int>& coins) {
        memset(dp,-1,sizeof(dp));
       int res=helper(coins,amount,coins.size());
        return  res;
    }
};

solver-Arpit
setter-Karan
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        if(k%2==0 || k%5==0){
            return -1;
        }
        int rem=0;
      for(int i=1;i<=k;i++){
          rem=((rem*10)+1)%k;
          if(rem%k==0){
              return i;
          }
      }
        return -1;
    }
};

solver-Arpit
setter-Gajendra
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& first, vector<vector<int>>& second) {
         int i=0,j=0;
        vector<vector<int>>ans;
        while(i<first.size() && j<second.size()){
            vector<int>v;
           v.push_back(max(first[i][0],second[j][0]));
           v.push_back(min(first[i][1],second[j][1]));
           if(v[0]<=v[1])
           ans.push_back(v);
           if(first[i][1]<second[j][1]){
               i++;
           }
            else if(first[i][1]==second[j][1]){
                i++; j++;
            }
            else{
                j++;
            }
        }
        return ans;
    }
};

Solver: Gajendra
Setter: Karan
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        if(k%2==0 || k%5==0)
            return -1;
        
        int len=1;
        int num=1;
        while(num%k!=0)
        {
            len++;
            num=(num%k)*10+1;
        }
        return len;
    }
};


SOLVER : ASHISH
GIVER: GAJENDRA

SOLN:
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& f, vector<vector<int>>& s) {
//         leaving points of a
        set<int> a_leaving_points;
        set<int> b_leaving_points;
        
        set<int> store;
        for(auto x:f){
            store.insert(x[0]);
            store.insert(x[1]);
            a_leaving_points.insert(x[1]);
        }
        
       
         for(auto x:s){
            store.insert(x[0]);
            store.insert(x[1]);
            b_leaving_points.insert(x[1]);
        }
    map<int,vector<int>> mapping;
     for(auto x: store){
         mapping[x] = {0,0};
     }
    for(auto x:f){
mapping[x[0]][0]++;
mapping[x[1]][0]--;
    }
        
        
        for(auto x:s){
mapping[x[0]][1]++;
mapping[x[1]][1]--;
    }    
        

        int pre1 = 0;
        int pre2 = 0;
        for(auto x: mapping){
            int t = x.first;
            vector<int> v = x.second;
            v[0]+=pre1;
            pre1 = v[0];
            v[1]+=pre2;
            pre2 = v[1];
            mapping[t] = v;
            
        }
    
        
     vector<vector<int>> ans;
        int process = -1;
        for(auto x: mapping){
            vector<int> v = x.second;
            if(v[0]+v[1]==2){
                process = x.first;
                continue;
            }
            
            
            int a = v[0];
            int b = v[1];
            if(a_leaving_points.count(x.first)){
                a++;
            }
            if(b_leaving_points.count(x.first)){
                b++;
            }
            if(a+b==2){
                if(process!=-1){
                    ans.push_back({process,x.first});
                    process = -1;
                }
                else{
                    ans.push_back({x.first,x.first});
                }
            }
            
            
            
        }
        
        
      return ans;  
        
        
    }
};
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Date:31/12/2021
Questions:
Karan -> https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/
Gajendra -> https://leetcode.com/problems/backspace-string-compare/
---------------------------------------------------------------------------------------
Solutions:

solver-Arpit
setter->Karan
class Solution {
public:
    int maxAncestorDiff(TreeNode* root,int mn=100000,int mx=0) {
       if(root==NULL){
           return mx-mn;
       }
        mx=max(mx,root->val);
        mn=min(mn,root->val);
        return max(maxAncestorDiff(root->left,mn,mx),maxAncestorDiff(root->right,mn,mx));
    }
};

Solver:Gajendra
Setter:Karan
class Solution {
public:
    int calc(TreeNode* r,int maxx,int minn)
    {
        if(r==NULL)return maxx-minn;
        maxx=max(maxx,r->val);
        minn=min(minn,r->val);
        
        return max(calc(r->left,maxx,minn),calc(r->right,maxx,minn));
    }
    
    int maxAncestorDiff(TreeNode* root) {
    return calc(root,INT_MIN,INT_MAX);
}
};
---------------------------------------------------------------------------------------------


Date: 01/01/2022

Questions: 

Gajendra -> https://leetcode.com/problems/subarray-product-less-than-k/
Karan -> https://leetcode.com/problems/3sum-closest/

Backspace string problem solution ---->

class Solution {
public:
    bool backspaceCompare(string s, string t) {
        stack<char>s1, s2;
        for(auto x:s){
            if(x=='#'){
                if(s1.size()==0){continue;}
                s1.pop();
            }else{
                s1.push(x);
            }
        }
        for(auto x:t){
            if(x=='#'){
                if(s2.size()==0){continue;}
                s2.pop();
            }else{
                s2.push(x);
            }
        }
        if(s1.size()!=s2.size()){return false;}
        while(s1.size()!=0){
            if(s1.top()!=s2.top()){return false;}
            s1.pop();s2.pop();
        }
        return true;
    }
};


From ASHISH 
https://leetcode.com/problems/burst-balloons/submissions/




-
Date : 02/01/2022

Questions:

Gajendra ->https://leetcode.com/problems/subarray-sum-equals-k/submissions/
ASHISH-https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/submissions/
Karan -> https://leetcode.com/problems/first-unique-character-in-a-string/submissions/
----------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra
 class Solution {
public:
    int subarraySum(vector<int>& v, int k) {
       map<int,int> m;
        m[0]=1;
        int s=0,res=0;
        for(auto i:v)
        {
            s+=i;
            if(m.find(s-k)!=m.end())
                res+=m[s-k];
            m[s]++;
        }
        return res;
    }
};
Solver:Gajendra
Setter:Ashish

class Solution {
public:
    int numPairsDivisibleBy60(vector<int>& time) {
        map<int,int>m;
        int res=0;
        for(auto i:time)
        {
            
            int req=(60-(i%60))%60;
            
            if(m.find(req)!=m.end())
                res+=m[req];
            
            m[i%60]++;
        }
        return res;
    }
};



-------------------------------------------------------------------------------------------


SETTER: ASHISH 
SOLVER: ASHISH

class Solution {
public:
    int numPairsDivisibleBy60(vector<int>& time) {
        vector<int> rem;
        for(auto x: time){
            rem.push_back(x%60);  
        }
        multiset<int>counter;
        int ans = 0;
        for(auto x: rem){
            if(x==0){
                ans+=(counter.count(0));
                counter.insert(x);
                continue;
            }
            ans+=(counter.count(abs(60-x)));
            counter.insert(x);
            
            
        }
       return ans; 
        
    }
};

---------------------------------------------------------------------------------------------


Date: 03/01/2022

Questions: 

Karan -> https://leetcode.com/problems/find-the-town-judge/

<<<<<<< HEAD
ASHISH:
https://leetcode.com/problems/find-the-town-judge/submissions/





SETTER ASHISH:
SOLVER:ASHISH

-- TOWN'S JUDGE 

class Solution {
public:
    int findJudge(int n, vector<vector<int>>& trust) {
         if(n==1){return 1;}
        if(trust.size()==0){return -1;}
        
        
//        here dp -> two cols
//                -> n rows
//         first col of any row => tells ith's frequency of given trust
//          second col of any row=> tells ith's freq of taken trust
        
// SO AFTER FILLING MY DP arrays just find num of ith for which first col -> 0 and second col-> n-1
//         if such ith is more than one return -1
//         else return that ith
        //---  EDGE CASE IF n == 1 return 1
        
        vector<vector<int>> dp(n+1,{0,0});
        for(auto x: trust){
            dp[x[0]][0]++;
            dp[x[1]][1]++;
        }
        
        set<int> ans;
        int count = 1;
        for(int i = 1; i<=n; i++){
            vector<int> x = dp[i];
            if(x[0]==0 && x[1]==n-1){
                ans.insert(count);
            }
            count++;
        }
        
        if(ans.size()==1){return *ans.begin();}
        
        return -1;
        
    }
};
=======
---------------------------------------------------------------------------------------------


Date: 04/01/2022

Questions: 

Karan -> https://leetcode.com/problems/complement-of-base-10-integer/
>>>>>>> cee71f6c8cced676092b544b8c17ce55368dccd8


Setter Karan
Solver Arpit

class Solution {
public:
    int bitwiseComplement(int n) {
        if(n==0) return 1;
     int k=0;
     int bits=log2(n)+1;
     while(bits>0){
         n^=1<<k;
         k++;
         bits--;
     }
    return n;
    }
};

Setter Karan
Solver Ashish


class Solution {
public:
    int bitwiseComplement(int n) {
      int x = 1;
        int count = 2;
        while(n>x){
            x = ((1<<count)-1);
            count++;
        }
        
        return x^n;
        
    }
};

<<<<<<< HEAD


Solver -> Gajendra
Setter -> Karan

function decimalToBinary(num)
{
    var res="";
    while(num>0)
    {
        // console.log(num)
        var a=num%2
        num=Math.floor(num/2);
        if(a==1)
            res=res+"0"
        else
            res=res+"1"
    }
    
    return res;
}
var bitwiseComplement = function(n) {
    if(n==0)
        return 1
    var binary=decimalToBinary(n);
    var res=[...binary].reverse().join("");
    // console.log(res)
    var len=res.length-1
    var num=0
    // console.log(res.length)
    for(var a=0;a<res.length;a++)
    {
        // console.log("Tihs")
        if(res[a]=='1')
         num+=2**len
        len--
    }
    return num
    
};

--------------------------------------------------------------------------

Date: 05/01/2022

Questions: 

Karan -> https://leetcode.com/problems/palindrome-partitioning/

<<<<<<< HEAD




SETTER: KARAN 
SOLVER: ASHISH


class Solution {
public:
    
    
    
//     just a recursion which takes all valid substring as per questions 
    void solver(vector<vector<bool>> &dp, int i , string s , vector<vector<pair<int,int>>> &ans, vector<pair<int,int>> temp){
        
        
        if(i==s.length()){
            ans.push_back(temp);
        }
        
        for(int t = 0; t<s.length()-i; t++){
            
            if(dp[i][i+t]){
                temp.push_back({i,i+t});
                solver(dp,i+t+1,s,ans,temp);
                temp.pop_back();
            }
            
            
        }
        
        
        
    }
    
    
    vector<vector<string>> partition(string s) {
        vector<bool> f(s.length(),true);
        vector<vector<bool>> dp(s.length(),f);
        
//         dp vector takes i,j and tells whether s[i,....j] is palindrome or not
     for(int i = s.length()-1; i>=0; i--){
         
         for(int j = s.length(); j>=0; j--){
             
             if(i<j){
                 if(s[i]==s[j]){
                     
                     dp[i][j] = dp[i+1][j-1];
                     
                 }
                     
                 else{
                     dp[i][j] = false;
                 }
             }
             
             
             
         }
         
     }   
        
        
        
 vector<vector<string>> final;
        
      vector<vector<pair<int,int>>> ans;
        vector<pair<int,int>> temp;
        
        solver(dp,0,s,ans,temp);
        
        
        for(auto x: ans){
              vector<string> kk;
            for(auto y: x){
                string f = "";
                for(int a = y.first; a<=y.second; a++){
                    f+=s[a];
                }
                kk.push_back(f);
                
                
            }
            final.push_back(kk);
            
        }
        
        
return final;
 
        
    }
};
=======
Solver -> Arpit
Setter ->Karan
class Solution {
public:
    vector<vector<string>>res;
    bool ispalindrome(string &s,int i,int j){
        while(i<=j){
            if(s[i]!=s[j]) return false;
            i++; j--;
        }
        return true;
    }
    void helper(string &s,int i, vector<string>&v){
          if(i==s.length()){
              res.push_back(v);
              return;
          }
        for(int k=i;k<s.length();k++){
        if(ispalindrome(s,i,k)){
            v.push_back(s.substr(i,k-i+1));
            helper(s,k+1,v);
            v.pop_back();
        }
        }
    }
    vector<vector<string>> partition(string s) {
        vector<string>v; 
        helper(s,0,v);
        return res;
    }
};

--------------------------------------------------------------------------

Date: 06/01/2022

Questions:

Gajendra -> https://leetcode.com/problems/minimum-path-sum/submissions/
Karan -> https://leetcode.com/problems/ransom-note/


---------------------------------------------
Solutions:
-----------------------------------------------------------
Solver -> Arpit
Setter ->Karan
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        vector<int>v(26,0);
       for(int i=0;i<magazine.length();i++){
           v[magazine[i]-'a']++;
       } 
        for(int i=0;i<ransomNote.length();i++){
           v[ransomNote[i]-'a']--;
           if(v[ransomNote[i]-'a']<0) return false;
       }
        return true;
    }
};
-----------------------------------------------------------
Solver -> Gajendra
Setter ->Gajendra

class Solution
{
public:
         map<pair<int,int>,int> m;
    int minSum(int i, int j, vector<vector<int>> &grid)
    {
   
        if(i==grid.size()-1&&j==grid[0].size())
            return 0;
        if (i == grid.size() || j == grid[0].size())
            return 40000*2;
        
        if(m.find({i,j})!=m.end())
            return m[{i,j}];
        
        return m[{i,j}]=min(grid[i][j] + minSum(i, j + 1, grid), grid[i][j] + minSum(i + 1, j, grid));
    }
    int minPathSum(vector<vector<int>> &grid){
        return minSum(0, 0, grid);
        }
};


--------------------------------------------------------------


07/01/2022

Questions:
Gajendra -> https://leetcode.com/problems/perfect-squares/
Karan -> https://leetcode.com/problems/linked-list-random-node/

solver->Arpit
setter->Karan

class Solution {
public:
       ListNode* head;   
    Solution(ListNode* head) {
       this->head=head;
    }
    
    int getRandom() {
        ListNode* t=head;
        int res=t->val;
        t=t->next;
        for(int i=1;t!=NULL;i++){
            if(rand()%(i+1)==0){
                res=t->val;
            }
            t=t->next;
        }
        return res;
    }
};

Solver-> Gajendra
Setter ->Gajendra

class Solution {
public:
    int t[100][10001];
     vector<int> choices;
    int minn(int n,int s) {
        if(s==0)
            return 0;
        
        if(n==0||s<0)
            return 1e9;
        
        if(t[n][s]!=-1)
            return t[n][s];
        
        return  t[n][s] = min(1+minn(n,s-choices[n]),minn(n-1,s)); 
    }
    
    int numSquares(int n) {
        
        for(int i=0;i*i<=n;i++)
            for(int j=0;j<=n;j++)
               t[i][j]=-1;
   
        for(int i=0;i*i<=n;i++)
            choices.push_back(i*i);
        
        return minn(choices.size()-1,n);
    }
};

-----------------------------------------------------------------
Questions:
Arpit-> https://leetcode.com/problems/remove-duplicates-from-sorted-array/
>>>>>>> daa557ad8a5b1b4eec3e43cf86331b6c2deaba68




Questions from ashish

https://leetcode.com/problems/cherry-pickup-ii/submissions/



SETTER : ASHISH
SOLVER:ASHISH


class Solution {
public:
    
    int store(vector<vector<int>> &grid, int i, int j, int k, vector<vector<vector<int>>> &vvv){
        
        if(i==grid.size()){
            return 0;
        }
        
        if(j==k){return 0;}
        if(j<0 || k<0 || j>=grid[0].size() || k>=grid[0].size()){
            return 0;
        }
        
        
        
        
//         lr lc ll
//         rr rc rl
//         cc cl cr
if(vvv[i][j][k]!=-1){
   
    return vvv[i][j][k];
}
int pre = grid[i][j]+grid[i][k];


int x = store(grid,i+1,j-1,k-1,vvv);
int y = store(grid,i+1,j-1,k,vvv);
int z = store(grid,i+1,j-1,k+1,vvv);

int a = store(grid,i+1,j,k-1,vvv);
int b = store(grid,i+1,j,k,vvv);
int c = store(grid,i+1,j,k+1,vvv);

int d = store(grid,i+1,j+1,k-1,vvv);
int e = store(grid,i+1,j+1,k,vvv);
int f = store(grid,i+1,j+1,k+1,vvv);
x = max(x,y);
x = max(x,z);
x = max(x,a);
x = max(x,b);
x = max(x,c);
x = max(x,d);
x = max(x,e);
x = max(x,f);
        
        
int final =  x+pre;
vvv[i][j][k] = final;
        return final;
        
        
        
    
        }
    

    int cherryPickup(vector<vector<int>>& grid) {
        
        
            vector<int> v(80,-1);
    vector<vector<int>> vv(80,v);
    vector<vector<vector<int>>> vvv(80,vv);
        
        return store(grid,0,0,grid[0].size()-1,vvv);
        
        
        
        
        
        
    }
};



-----------------------------------------------------------

Date:09/01/2022

Questions:
Gajendra -> https://leetcode.com/problems/ones-and-zeroes/
Arpit-> https://leetcode.com/problems/sudoku-solver/
        https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/

----------------------------------------------
Solutions:

Solver ->Gajendra
Setter ->Gajendra

class Solution {
public:
    int dp[101][101][601];
    int maxx(vector<string>&s,int m,int n,int i,map<int,pair<int,int>>&freq)
    {
        if(i==s.size())
            return 0;
        
        if(dp[m][n][i]!=-1)
            return dp[m][n][i];
        
        int ans1=0,ans2=0;
        ans2=maxx(s,m,n,i+1,freq);
        m=m-freq[i].first;n=n-freq[i].second;
        if(m>=0&&n>=0)
            ans1=1+maxx(s,m,n,i+1,freq);
        
        return dp[m+freq[i].first][n+freq[i].second][i] = max(ans1,ans2);
    }
    
    int findMaxForm(vector<string>& strs, int m, int n) {
        map<int,pair<int,int>> freq;//index , count(0,1)
        for(int i=0;i<=m;i++)
            for(int j=0;j<=n;j++)
                for(int k=0;k<strs.size();k++)
                    dp[i][j][k]=-1;
        for(int i=0;i<strs.size();i++)
        {
            int o=0,z=0;
            for(auto j:strs[i])
            {
                if(j=='1')
                    o++;
                else
                    z++;
            }
            freq[i]={z,o};
        }
            return maxx(strs,m,n,0,freq);    
    }
};


setter->Arpit
solver->Arpit

class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        bool x=solver(board);
    }
        bool solver(vector<vector<char>>& board){
          for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                if(board[i][j]=='.'){
                    for( char n='1';n<='9';n++){
                        if(isvalid(i,j,n,board)==true){
                            board[i][j]=n;
                            if(solver(board)==true)
                                   return true;
                            else
                                board[i][j]='.';
                        }
                    }
                    return false;
                }
            }
           }
            return true;
    }
    bool isvalid(int row,int col,char n,vector<vector<char>>& board){
        for(int i=0;i<9;i++){
           if(board[row][i]==n){
               return false;
           }
            if(board[i][col]==n){
                return false;
            }
            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==n){
                return false;
            }
        }
        return true;
    }
};
--------------------------------------------

Date: 10/01/2022
Questions: 

Gajendra -> https://leetcode.com/problems/minimum-falling-path-sum/
Karan -> https://leetcode.com/problems/add-binary/
ASHISH -> https://leetcode.com/problems/largest-rectangle-in-histogram/submissions/


------------------------------------------------------------------------
Solver:Ashish
Setter:AShish

#define ll int
#define vec(type,name) vector<type> name;
#define rep(a,b,c) for(ll i = a; i<b; i+=c)

class Solution {
public:
    int largestRectangleArea(vector<int>&v) {
        ll n = v.size();
       vec(ll,lft);
rep(0,v.size(),1){
    lft.push_back(0);
}

vec(ll,rgt);
rep(0,v.size(),1){
    rgt.push_back(0);
}

stack<ll> st;
rep(0,v.size(),1){
if(st.size()==0){
    st.push(i);
    continue;
}

if(v[i]>v[st.top()]){
    st.push(i);
    continue;
}
ll count = 0;
while(st.size()>0 && v[i]<=v[st.top()]){
count+=lft[st.top()];
count++;
st.pop();
}

lft[i] = count;
st.push(i);
}


while(st.size()){
    st.pop();
}


for(ll i = v.size()-1;i>=0; i--){
if(st.size()==0){
    st.push(i);
    continue;
}

if(v[i]>v[st.top()]){
    st.push(i);
    continue;
}
ll count = 0;
while(st.size()>0 && v[i]<=v[st.top()]){
count+=rgt[st.top()];
count++;
st.pop();
}

rgt[i] = count;
st.push(i);
}


ll m_area = INT_MIN;

for(ll i =0; i<v.size(); i++){
 
    m_area = max(m_area,(lft[i]+rgt[i]+1)*v[i]);
}

return m_area;
    }
};




Solver:Gajendra
Setter:Gajendra

class Solution {
public:
    
    int t[101][101];
    int minn(vector<vector<int>>& matrix,int i,int j)
    {
        if(j>=matrix[0].size()||j<0)
            return 1e9;
        
        if(i==matrix.size())
            return 0;
        
        if(t[i][j]!=-1)
            return t[i][j];
        
        return t[i][j] = matrix[i][j]+min(minn(matrix,i+1,j-1),min(minn(matrix,i+1,j),minn(matrix,i+1,j+1)));
        
    }
    
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int ans=INT_MAX;
        for(int i=0;i<101;i++)
            for(int j=0;j<101;j++)
                t[i][j]=-1;
        
        for(int i=0;i<matrix[0].size();i++)
        {
            int res1=minn(matrix,0,i);
            ans=min(ans,res1);
        }
        return ans;
    }
};

Solver:Gajendra
Setter:Karan

class Solution:
    def addBinary(self, a: str, b: str) -> str:
        return bin(int(a,2) + int(b,2))[2::]
        


--------------------------------------------------------------------------

Questions:

Date:11/01/2022

Gajendra -> https://leetcode.com/problems/next-greater-element-iii/
Karan -> https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
Gurdeep -> 


----------------------------------------------------------
Solutions:

Solver -> Gajendra
Setter -> Gajendra

class Solution {
public:
    int nextGreaterElement(int n) {
        vector<int>digits;
        int temp=n;
        while(temp>0)
        {
            digits.push_back(temp%10);
            temp=temp/10;
        }
        bool ans=false;
        int i=1;
        for(i=1;i<digits.size();i++)
        {
            if(digits[i]<digits[i-1])
            {ans=true;break;}
        }
        if(ans)
        {
            int minn=digits[i-1],pos=i-1;
            for(int j=i;j>=0;j--)
            {
                if(digits[j]>digits[i])
                {
                    if(digits[j]<minn)
                    {
                        pos=j;
                        minn=digits[j];
                    }
                }
            }
            swap(digits[i],digits[pos]); 
            sort(digits.begin(),digits.begin()+i,greater<int>());
            long long int res=0;
            reverse(digits.begin(),digits.end());
            for(int i=0;i<digits.size();i++){
                cout<<digits[i]<<" "; 
                res=res*10+digits[i];    
            }
            if(res>INT_MAX)
                return -1;
            return res;
        }
        else
            return -1;
    }
};

solver-> Arpit
setter-> Gajendra


class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int lastpeak=0;
        for(int i=1;i<nums.size();i++){
            if(nums[i]>nums[i-1]){
                lastpeak=i;
            }
        }
        if(lastpeak==0){
            return;
        }
        int x=lastpeak;
        for(int i=lastpeak+1;i<nums.size();i++){
            if(nums[i]>nums[lastpeak-1]){
                x=i;
            }
        }
        swap(nums[lastpeak-1],nums[x]);
        reverse(nums.begin()+lastpeak,nums.end());
        return;
    }
    
    int nextGreaterElement(int n) {
        long x=0;
        int z=n;
        vector<int>v;
        while(n>0){
            int rem=n%10;
            v.push_back(rem);
            n/=10;
        }
        reverse(v.begin(),v.end());
        nextPermutation(v);
        for(int i=0;i<v.size();i++){
             x=x*10+v[i]; 
        }
        if(x>INT_MAX){
            return -1;
        }
        if(x==z) return -1;
        return x;
    }
};




Solver -> Arpit
Setter -> Karan

class Solution {
public:
    int res=0;
      void helper(TreeNode* root,int sum){
          if(root==NULL){
              return;
          }
          sum=2*sum+(root->val);
          if(!root->left && !root->right){
              res+=sum;
          }
          helper(root->left,sum);
          helper(root->right,sum);
      }
    int sumRootToLeaf(TreeNode* root) {
        helper(root,0);
        return res;
    }
};


Solver ->Gajendra
Setter ->Karan

class Solution {
public:
    long long int res=0;
    void traverse(TreeNode* r ,string n)
    {
        if(r->left==NULL&&r->right==NULL)
        {
            n.push_back(r->val+'0');
            bitset<32>b(n);
             res+=b.to_ulong();
        }
            n.push_back(r->val+'0');
        if(r->left==NULL&&r->right!=NULL){
        traverse(r->right,n);
            }
        else if(r->left!=NULL&&r->right==NULL){
             traverse(r->left,n);
        }
        else if(r->left!=NULL&&r->right!=NULL)
        {
             traverse(r->left,n);
           traverse(r->right,n);
        }
    }
    
    int sumRootToLeaf(TreeNode* root) {
        traverse(root,"");
        return res;
    }
};

--------------------------------------------------------

Date: 12/01/2022

Questions:
Gajendra -> https://leetcode.com/problems/insert-into-a-binary-search-tree/
Karan -> https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/


---------------------------------------------------------------------------------
Solutions:

solver-> Arpit
setter-> Gajendra

class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode* q=root;
       TreeNode* newnode=new TreeNode(val);
        if(!q) return newnode;
       TreeNode* pre=root;
        while(root!=NULL){
          if(val<root->val){
              pre=root;
              root=root->left;
          }
         else{
             pre=root;
             root=root->right;
         }
        }
        if(val<pre->val){
            pre->left=newnode;
        }
        else{
            pre->right=newnode;
        }
        return q;
    }
};


Solver -> Gajendra
Setter -> Karan

class Solution {
public:
    vector<int> searchRange(vector<int>& v, int t) {
        
        if(binary_search(v.begin(),v.end(),t))
            return {int(lower_bound(v.begin(),v.end(),t)-v.begin()),int(upper_bound(v.begin(),v.end(),t)-v.begin()-1)};
        return {-1,-1};
        
    }
};

---------------------------------------------------------------------------------


Date: 13/01/2022

Questions
Arpit-> https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/
Karan-> https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/
Gajendra-> https://leetcode.com/problems/reverse-linked-list/

---------------------------------------------------------------------------------
Solutions:

solver-> Arpit
setter-> Arpit

class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(),points.end(),[&](vector<int>&a,vector<int>&b){
            return a[1]<b[1];
        });
        int count=1;
        int end=points[0][1];
        for(int i=1;i<points.size();i++){
            if(points[i][0]>end){
                count++;
                end=points[i][1];
            }
        }
        return count;
    }
};

Solver -> Gajendra
Setter-> Karan
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return head;
        ListNode* t=reverseList(head->next);
        head->next->next=head;
        head->next=NULL;
        return t;
    }
    int pairSum(ListNode* head) {
        ListNode* slow=head,*fast=head;
        while(fast!=NULL&&fast->next!=NULL)
        {
            slow=slow->next;
            fast=fast->next->next;
        }
        cout<<slow->val<<endl;
        ListNode* temp=reverseList(slow);
        int sum=0;
        while(temp!=NULL)
        {
            sum=max(sum,temp->val+head->val);
            head=head->next;
            temp=temp->next;
        }
        return sum;
        
    }
};

Solver -> Gajendra
Setter -> Gajendra


class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==NULL||head->next==NULL)
            return head;
        ListNode* t=reverseList(head->next);
        head->next->next=head;
        head->next=NULL;
        return t;
    }
};

Solver -> Gajendra
Setter -> Arpit

class Solution {
public:
    static bool cmp(vector<int>& a, vector<int>& b) {return a[1] < b[1];}
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(),points.end(),cmp) ;
        int arrows=1,end=points[0][1];
        for(int i=0;i<points.size();i++)
        {
            if(i+1>=points.size())
                return arrows;
            
            if(end>=points[i+1][0])
                continue;
            else
            {   
                end=points[i+1][1];
                    arrows++;
            }
        }
        return arrows;
    }
};
// 1-6 2-8 7-12 10-16


--------------------------------------------------------------------

Date: 14/01/2022

Questions:
Ashish->https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/submissions/
Karan-> https://leetcode.com/problems/product-of-array-except-self/submissions/


Solution :
----------------------------------------------------------------------------------------

Ans from Ashish

class Solution {
public:
    int i = 0;
    TreeNode* maker(TreeNode* &root, int x, int y,vector<int>&p){
        if(i>=p.size()){
            return NULL;
        }
        if(x>y){return NULL;}
        if(!(p[i]>=x && p[i]<=y)){
            return NULL;
        }
        
        root = new TreeNode(p[i]);
        int t = p[i];
        i++;
    TreeNode* lft = maker(root->left,-2000,t-1,p);
    TreeNode* rgt = maker(root->right,t+1,max(t+1,y),p); 
        root->left = lft;
        root->right = rgt;
        return root;
            
    }
    
    
    
    TreeNode* bstFromPreorder(vector<int>& p) {
        
        
        TreeNode* root = NULL;
      return maker(root,-2000,2000,p);
        
        
    }
};


Solver -> Gajendra
Setter-> Karan

class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int count_zero=0,prod=1;
        for(auto i:nums)
        {
            if(i==0)
                count_zero++;
            if(i!=0)
                prod*=i;
            if(count_zero>1)
            {
                for(auto &i:nums)
                    i=0;
                return nums;
            }
        }
        if(count_zero==1)
        {
            for(auto &i:nums)
            {
                if(i!=0)
                    i=0;
                else
                    i=prod;
            }
            return nums;
        }
        else
        {
            vector<int>right{1};
            for(int i=nums.size()-1;i>=0;i--)
                right.push_back(right.back()*nums[i]); 
            right.pop_back();
            reverse(right.begin(),right.end());
            int prod=1;
            for(int i=0;i<nums.size();i++)
            {
                right[i]=prod*right[i];
                prod*=nums[i];
            }
            return right;
        }
    }
};

--------------------------------------------------------------------------

Date: 15/01/2022

Questions:
Gajendra-> https://leetcode.com/problems/jump-game/
Karan -> https://leetcode.com/problems/number-of-laser-beams-in-a-bank/


-------------------------------------------------------------------------
Solutions:

Solver->Gajendra
Setter->karan

class Solution {
public:
    int numberOfBeams(vector<string>& bank) {
     int res=0,prev=0;
     for(auto i:bank)
     {
         int temp=0;
         for(auto j:i)
         {
             if(j=='1')
                 temp++;
         }
         if(temp!=0)
         {
              if(prev!=0)
                res+=temp*prev;
             prev=temp;
         }
     }
        return res;
    }
};

Solver -> Gajendra
Setter -> Gajendra

class Solution {
public:
    int arr[10001];
    bool can(int i,vector<int>&v)
    {
        if(i>=v.size() || i+v[i]>=v.size()-1)
            return true;
        
        if(v[i]==0)
            return false;
        
        if(arr[i]!=-1)
            return arr[i];
        
        bool ans=false;
        for(int j=i+1;j<=i+v[i];j++)
            ans = ans || can(j,v);
        
        return arr[i] = ans;
    }
    bool canJump(vector<int>& nums) {
        for(int i=0;i<=nums.size();i++)
            arr[i]=-1;
        return can(0,nums);
    }
};


-------------------------------------------------------------------------


Date:16/01/2022
Questions: 
Gajendra-> https://leetcode.com/problems/jump-game-ii/
Karan -> https://leetcode.com/problems/maximize-distance-to-closest-person/

-----------------------------------------------------------
Solutions:

Solver -> Gajendra
Setter -> Karan
class Solution {
public:
    int maxDistToClosest(vector<int>& v) {
        int beg=0,end=v.size()-1,res=0;
        while(beg<v.size()&&v[beg]!=1)
            beg++;
        while(end>=0&&v[end]!=1)
            end--;
        beg=beg;
        end=v.size()-end-1;
        int i=0;
        while(i<v.size())
        {
            if(v[i]==1)
            {
                int a=i;
                i++;
                while(i<v.size()&&v[i]==0)
                    i++;
                int b=i;
                if(b==v.size())
                    return max(res,max(beg,end));
                else
                int distance_from_left=(a+b)/2-a;
                int distance_from_right=b-(a+b)/2;
                res=max(res,min(distance_from_left,distance_from_right));
            }
            else
                i++;
        }
        return 0;
    }
};

----------------------------------------------------------------------------

Date:17/01/2022
Questions: 

Karan -> https://leetcode.com/problems/word-pattern/

----------------------------------------------------------------------------

Date:17/01/2022
Questions: 
Karan -> https://leetcode.com/problems/can-place-flowers/


------------------------------------------------------------------------------
Solutions:

ASHISH HAS
SOLVED KARAN'S QUE
class Solution {
public:
    bool canPlaceFlowers(vector<int>& f, int n) {
        
        vector<int> v = f;
        for(int i =0; i<f.size(); i++){
            if(f[i]){
                if(i+1<f.size()){
                    v[i+1] = 1;
                }
                 if(i-1>=0){
                     v[i-1] = 1;
                 }
            }
        }
        
        
        
//         done with v
        int total = 0;
        int curr = 0;
        for(int i =0; i<v.size(); i++){
            
            if(v[i]==0){
                curr++;
            }
            else{
                int t= curr%2? (curr+1)/2:curr/2;
                curr = 0;
                total+=t;      
                
            }
              
        }
           int t= curr%2? (curr+1)/2:curr/2;
                curr = 0;
                total+=t;
        
    return total>=n;
        
    }
};

Solver -> Gajendra
Setter -> Karan

class Solution {
public:
    bool canPlaceFlowers(vector<int>& v, int n) {
        if(n==0)return true;
        if(v.size()==1)
        {
            if(v[0]==0)
                return n==1;
            return false;
        }
        else if(v.size()==2)
        {
            if(v[0]==0&&v[1]==0)
                return n==1;
            return false;
        }
        int res=0;
        if(v[0]==0&&v[1]==0)
        {v[0]=1;res++;}
        for(int i=1;i<v.size()-1;i++)
        {
            if(v[i-1]==0&&v[i+1]==0&&v[i]==0){
                v[i]=1;res++;}
        }
        if(v.back()==0&&v[v.size()-2]==0){
            v.back()=1;res++;}
        return res>=n;
    }
};


--------------------------------------------\
Date: 20/01/2022

Ashish -> https://leetcode.com/problems/koko-eating-bananas/submissions
Gajendra -> https://leetcode.com/problems/permutations/


----------------------------------------------------------
Solutions:

Solver -> Gajendra
Setter -> Ashish

class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        def condition(value) -> bool:
            time=0
            for gp in piles:
                time+=ceil(gp/value)
            print(value,time)
            return time<=h
        
        left, right = 1,max(piles)
        while left < right:
            mid = left + (right - left) // 2
            if condition(mid):
                right = mid
            else:
                left = mid + 1
        return left
    

-----------------------------------------------------------------------------


Questions: 21/01/2022

Gajendra -> https://leetcode.com/problems/gas-station/

---------------------------------------------------------------
Solutions: 
Solver -> Gajendra
Setter -> Gajendra

class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int t[100000]={0};
        for(int i=0;i<gas.size();i++)
        {
            if(t[i]==-1)
                continue;
            int fuel=0,j=i;
            while(true)
            {
                fuel+=gas[j];
                if(cost[j]>fuel)
                    break;
                else
                    fuel-=cost[j];
                
                t[j]=-1;
                j=(j+1)%gas.size();

                if(j==i)
                    return i;
            }
        }
        return -1;
    }
};

Ashish:  Gas Station from leetcode
SOLN from ashish
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        if(gas.size()==1){
           return gas[0]>=cost[0]?0:-1;
        }
        vector<int> track;
        for(int i =0; i<cost.size(); i++){
            track.push_back(gas[i]-cost[i]);
        }
        for(int i = 1; i<track.size(); i++){   
            track[i]+=track[i-1];
        }
        multiset<int> store1;
        multiset<int> store;
        for(auto x: track){
            store1.insert(x);
        }
        for(int i=0; i<track.size(); i++){   
            if(i==0){
                int min = *store1.begin();
          
             if(min>=0){
                 return 0;
             }
            store1.erase(store1.find(track[i]));
            store.insert(track[i]);   
        }       
    else{
        int min = *store1.begin();
        int t = min-track[i-1];
        int last = track.back()-track[i-1];
        if(t>=0 && (*store.begin()+last>=0)){
            return i;
        }
        store.insert(track[i]);
        store1.erase(store1.find(track[i]));
    } }       
        return -1;
    }
};


---------------------------------------------------------------------------------

Ashish Question

https://leetcode.com/problems/partition-labels/submissions/

class Solution {
public:
    vector<int> partitionLabels(string s) {
//         stack for storing intervals
        stack<vector<int>> st;
        map<char,int> track;
//         for knowing farthest index of any char, if -1 then not found yet
        for(auto x: s){
            track[x] = -1;
        }
        
        
//     iterating string from back and store intervals and remove accoding to below algorithms    
        for(int i = s.length()-1; i>=0; i--){
            
            if(track[s[i]]==-1){
                track[s[i]] = i;
                st.push({i,i});
            }
            
            else{
                
                
                int start = i;
                int end = track[s[i]];
                int tt = end;
                while(st.size() && st.top()[0]<=end){
                    tt = max(tt,st.top()[1]);
                    st.pop();
                }
                st.push({start,tt});
                
                
            }
            
            
        }
        
        
        
  vector<int> ans;
        while(st.size()){
            vector<int> v = st.top();
            ans.push_back(v[1]-v[0]+1);
                st.pop();
        }
        
     
        return ans;
        
        
        
    }
};


-----------------------------------------------------------------------------


Questions: 21/01/2022

Karan -> https://leetcode.com/problems/container-with-most-water/

-----------------------------------------
Solutions:

Solver -> Gajendra
Setter -> Karan

class Solution {
public:
    int maxArea(vector<int>& height) {
        int left=0,right=height.size()-1;
        int water=INT_MIN;
        while(left<right)
        {
            water=max(water,min(height[left],height[right])*(right-left));
            if(height[left]<height[right])
                left++;
            else
                right--;
        }
        return water;
    }
    
};

--------------------------------------------------------



Date : 23/01/2022

Questions:
Gajendra->https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/submissions/

---------------------------
Solutions:

Solver: Gajendra
Setter: Gajendra

 var findLonely = function(arr) {

    function getMapValue(ele) {
      if (map1.get(ele) == undefined) return 0;
      return map1.get(ele);
    }    
    
    const map1 = new Map();
  
    const res = [];

    for (const ele of arr) {
      map1.set(ele, getMapValue(ele) + 1);
    }
    

    for (const ele of arr) {
      if (
        map1.get(ele) == 1 &&
        getMapValue(ele - 1) == 0 &&
        getMapValue(ele + 1) == 0
      )
        res.push(ele);
    }
    
    return res;
    
};

------------------------------------------------------------------

ASHISH

https://leetcode.com/problems/longest-valid-parentheses/submissions/

--------------------------------------------------------
Date : 24/01/2022
Questions:
Karan -> https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/
Gajendra -> https://leetcode.com/problems/sequential-digits
Ashish -> https://leetcode.com/problems/binary-tree-right-side-view/
---------------------------
Solutions:
Setter: Karan
Solver: Gajendra

 var findLonely = function(arr) {

    function getMapValue(ele) {
      if (map1.get(ele) == undefined) return 0;
      return map1.get(ele);
    }    
    
    const map1 = new Map();
  
    const res = [];

    for (const ele of arr) {
      map1.set(ele, getMapValue(ele) + 1);
    }
    

    for (const ele of arr) {
      if (
        map1.get(ele) == 1 &&
        getMapValue(ele - 1) == 0 &&
        getMapValue(ele + 1) == 0
      )
        res.push(ele);
    }
    
    return res;
    
};

------------------------------------------------------------------

Date: 25/01/2022

Questions:
Gajendra -> https://leetcode.com/problems/next-permutation/
Karan -> https://leetcode.com/problems/valid-mountain-array/

-----------------------------------------------------------------


Date:26/01/2022

Questions:
Gajendra-> https://leetcode.com/problems/next-permutation/



Ashish Question
https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/submissions/
Karan -> https://leetcode.com/problems/palindrome-number/
Gajendra -> https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/submissions/

--------------------------------------------------------------------------

Date: 29/01/2022
Questions:
Gajendra -> https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/


---------------------------------------------------------------------------

Date:30/01/2022
Questions:
Gajendra -> https://leetcode.com/problems/find-substring-with-given-hash-value/
---------------------------------------------------------------------------

Date:3/02/2022
Questions:
Karan -> https://leetcode.com/problems/find-all-anagrams-in-a-string/
Ashish: https://leetcode.com/problems/find-substring-with-given-hash-value/submissions/




Solution by Ashish to Ashish 


#define ll long long

class Solution {
public:
       string solve(string&s,ll p, ll m, ll k, ll hv)
{
    ll hash = 0;
    ll pk = 1;
    ll kk = k-1;
    //  finding pk
    while(kk--){
    pk*=p;
    pk%=m;
    }


ll answer = -1;
ll i =  s.length()-1;
ll cnt = 0;
while(i>=0){
if(cnt>=k){
ll to_be_remove = s[i+k]-'a'+1;
hash = (hash-(to_be_remove*pk)%m+m)%m;
hash = (hash*p+(s[i]-'a'+1))%m;
}
else{
hash = (hash*p+(s[i]-'a'+1))%m;
}
cnt++;

if(cnt>=k && hv==hash) answer = i;
i--;
}



string final = "";

for(ll i = answer; i<=answer+k-1; i++){
    final+=s[i];
}
return final;


}
    
    
    string subStrHash(string s, int p, int m, int k, int hv) {
        
        string res = solve(s,p,m,k,hv);
        return res;
    }
};
---------------------------------------------------------------------------

Date:9/02/2022

Questions:

Karan -> https://leetcode.com/problems/k-diff-pairs-in-an-array/

-------------------------------------------------------------------------
Date:10/02/2022
Questions for weekend:

Gajendra -> https://leetcode.com/problems/find-substring-with-given-hash-value/submissions/
	https://leetcode.com/problems/3sum/submissions/
https://leetcode.com/problems/3sum-closest/


13 FEB
From Ashish

https://leetcode.com/contest/biweekly-contest-71/problems/partition-array-according-to-given-pivot/


-------------------------------------------------------------------------
Date:10/02/2022

Karan -> https://leetcode.com/problems/swap-nodes-in-pairs/


-------------------------------------------------------------------------


Date:19/02/2022

Karan -> https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/


-------------------------------------------------------------------------


Date:20/02/2022

Karan -> https://leetcode.com/problems/maximum-split-of-positive-even-integers/
Gajendra -> https://leetcode.com/problems/3sum/submissions/ , https://leetcode.com/problems/3sum-closest/ , https://leetcode.com/problems/decode-ways/

-------------------------------------------------------------------------


Date:21/02/2022

Karan -> https://leetcode.com/problems/majority-element/