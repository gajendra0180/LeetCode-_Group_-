Date:10/12/2021
Gajendra -https://leetcode.com/problems/merge-intervals/
Gajendra- https://leetcode.com/problems/sort-colors/submissions/
Karan -https://leetcode.com/problems/longest-substring-without-repeating-characters/
ASHISH - https://leetcode.com/problems/next-permutation/

----------------------------------------------------------


//ASHISH
//first soln
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& v) {
        if(v.size()==1){return v;}
      sort(v.begin(),v.end());
        vector<vector<int>> ans;
        ans.push_back(v[0]);
        for(int i = 1; i<v.size(); i++){
            
            if(ans.back()[1]<v[i][0]){
                ans.push_back({v[i][0],v[i][1]});
            }
            else{
                int new_first = ans.back()[0];
                int new_second = max(ans.back()[1],v[i][1]);
                ans.pop_back();
                ans.push_back({new_first,new_second});
            }
            
            
        }
        return ans;
    }
};

//2nd soln

class Solution {
public:
    void sortColors(vector<int>& nums) {
    int zero = 0;
    int one = 0;
    int two = 0;
    for(auto x: nums){
        if(x==0){zero++;}
        else if(x==1){one++;}
        else{two++;}
    }
    for(int i =0; i<nums.size(); i++){
        if(zero){
            nums[i] = 0;
            zero--;
        }
        else if(one){
            nums[i] = 1;
            one--;
        }
        else{
            nums[i] = 2;
            two--;
        }
    }

    }
};



//3rd solution

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       if(s.length()==0 || s.length()==1){
           return s.length();
       }
        
        map<char,int> store;
        for(int i =0; i<s.length();i++){
            store[s[i]] = i;
        }
       
     
        vector<int>ans;
        for(int i =0; i<s.length();i++){
            ans.push_back(0);
        }
        ans[s.length()-1] = 1;
        for(int i = s.length()-2;i>=0;i--){
            if(store[s[i]]>i){
                
             int xx = store[s[i]]-i;
             int yy = ans[i+1]+1;
                ans[i] = min(xx,yy);
                store[s[i]] = i;
            }
            else if(store[s[i]]<=i){
                ans[i]=ans[i+1]+1;
                
                 store[s[i]] = i;
                
            }
        }
        sort(ans.begin(),ans.end());
        return ans[ans.size()-1];
        
    }
};

-------------------------------------------------------------------




Dated: 11/12/2021


Questions:
Gajendra-https://leetcode.com/problems/nth-magical-number/
Arpit- https://leetcode.com/problems/count-complete-tree-nodes/submissions/
Karan - https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

Ashish-
https://leetcode.com/problems/swap-nodes-in-pairs/





Solutions:

----------------------------------------------------------------------------

Ashish:
my que soln:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
       if(head==NULL || head->next==NULL){
           return head;
       } 
        
        ListNode* pre = NULL;
        ListNode* pos = head;
        while(pos!=NULL){
            if(pre==NULL){
                 if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre = pos;
                head = mid;
                pos = st;
            }
            else{
                if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre->next = mid;
                pre = pos;
                pos = st;
                
            }
            
            
        }
        return head;
    }
};



Ashish : karan's que ans
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define tn TreeNode
class Solution {
public:
    TreeNode* recoverFromPreorder(string t) {
        
        int d = 0;
        int v = 0;
        map<tn*,int> map_dist;
        map<tn*,vector<int>> map_allow;
        tn* root = NULL;
        stack<tn*> myset;
    
        for(auto x: t){
          
            if(x!='-'){
                v = v*10+(x-'0');
                
              
               
             
            }
            else{
            
               if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                       continue;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
                
                
                d++;
                
                
                
            }
        }
        
        if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                      return root;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
        return root;
        
        
    }
};

ASHISH: Gajendra que ans
#define ll long long
ll gcd(ll a, ll b){
    if(a==0){return b;}
    if(b==0){return a;}
    return gcd(b, a%b);
}
ll lcm(ll a, ll b){
    return (a*b)/gcd(a,b);
}
class Solution {
public:
    int nthMagicalNumber(int nn, int a, int b) {
        ll aa = (ll)a;
        ll bb = (ll)b;
        ll n = nn;
        ll left = 1;
        ll k = lcm(aa,bb);
        ll right = 1e18;
        ll ans = 1e18;
        while(left<=right){
            ll mid = (left+right)/2;
            ll target = (mid/aa)+(mid/bb)-(mid/k);
            if(target<n){
                left = mid+1;
            }
            else{
                if(target==n){
                    ans = min(ans, mid%(1000000007));
                }
                right = mid-1;
            }
           
        }
       return ans; 
    }
};


Arpit:
Solution 2nd question
class Solution {
public:
    int heightl(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->left;
      }
        return h;
    }
     int heightr(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->right;
      }
        return h;
    }
    int countNodes(TreeNode* root) {
        if(root==NULL)
            return 0;
        int l=heightl(root);
        int r=heightr(root);
        if(l==r){
          return pow(2,l)-1;
        }
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

Solution 3rd question
class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
        
        map<string,pair<TreeNode*,int>>m;
            int num=0;string v="";
        TreeNode* z=NULL;int x;
        TreeNode* root=NULL;
        for(int i=0;i<s.length();i++){
            if(s[i]>=48 && s[i]<=57){
                 num=0;
                while(i<s.length() && s[i]>=48 && s[i]<=57){
                    num=num*10+(s[i]-48);
                    i++;
                }
                i--;
                  z=new TreeNode(num);
                if(root==NULL)
                    root=z;
                else{
                  root=m[v].first;
                  x=m[v].second;
                    if(x==0){
                        root->left=z;
                    }
                    if(x==1){
                        root->right=z;
                    }
                }
            }
            else{
               int l=v.length();
                 v="";
               while(s[i]=='-'){
                   v.push_back('-');
                   i++;
               }
               int u=v.length();
                i--;
                if(m.find(v)==m.end()){
                    m[v]={z,0};
                }
                else if(m.find(v)!=m.end() && m[v].second!=1){
                    m[v].second++;
                }
                else{
                    m[v]={z,0};
                }
                if(l>u){
                for(auto it=++m.find(v);it!=m.end();it++){
                    (*it).second.second=1;
                }
                }
            }
        }
        if(m.size()==0){
            return z;
        }
        auto pair=m["-"];
        return pair.first;
    }
};



Gajendra:
1st ques:
class Solution {
public:
    
    
    bool condition(long long int mid,long long int req,long long int a,long long int b,long long lcm)
    {
        long long int posx=mid/a+mid/b-(mid/lcm);
        if(posx<req)
            return false;
        return true;
    }
    
    int nthMagicalNumber(int n, int a, int b) {
        long long int gcd=__gcd(a,b);
        long long int lcm=a*b/gcd;
       long long int left=1,right=1e18;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            if(condition(mid,n,a,b,lcm))
                right=mid;
            else
                left=mid+1;
        }
        int mod=1e9+7;
        return left%mod;
    }
};

2nd ques:
class Solution {
public:
    int lheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+lheight(root->left);
    }
    
    int rheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+rheight(root->right);
    }
    int countNodes(TreeNode* root) {
      
        if(!root)return 0;
        
        int l=lheight(root->left);
        int r=rheight(root->right);

        
        if(l==r)
            return pow(2,l+1)-1;
        
        cout<<l<<" "<<r<<endl;
        
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

3rd question:


class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
     
        map<int,TreeNode*> m;
        int current_level=0,chk=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]=='-')
                current_level++;
            else
            {
                string num;
                while(i<s.size()&&s[i]>='0'&&s[i]<='9')
                {
                    num.push_back(s[i]);
                    i++;
                }
                
                i--;
                
                stringstream ss;
                ss<<num;
                int n;
                ss>>n;
                
                TreeNode* temp=new TreeNode(n);
                
                m[current_level]=temp;
                
                if(current_level){
                    
                if(m[current_level-1]->left)
                    m[current_level-1]->right=temp;
                else
                    m[current_level-1]->left=temp;
                }
                current_level=0;
            }
        }
        return m[0];
    }
};

-----------------------------------------------------------------------------

<<<<<<< HEAD
=======

>>>>>>> 220a8bba66c07ac446287a9879dd949553d41b73



Date:12/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/ugly-number-iii
Ashish->   https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
Karan-> https://leetcode.com/problems/letter-combinations-of-a-phone-number/

-------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

1st ques:
class Solution {
public:
    
    bool condition(long long int mid,long long int l1,long long int l2,long long int l3,long long int l4,long long int a,long long int b,long long int c,long long int req)
    {
        long long int n=mid/a+mid/b+mid/c-mid/l1-mid/l2-mid/l3+mid/l4;
        // cout<<mid<<" "<<n<<endl;
        if(n<req)
            return false;
        return true;
    }
    
    int nthUglyNumber(long long int n, long long int a, long long int b, long long int c) {
        long long int left=1,right=1e18;
        long long int lcm1=(a*b)/__gcd(a,b);
        long long int lcm2=(b*c)/__gcd(b,c);
        long long int lcm3=(a*c)/__gcd(a,c);
        long long int lcm4=a*lcm2/(__gcd(a,lcm2));
        // cout<<lcm1<<lcm2<<lcm3<<lcm4<<endl;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            // cout<<left<<" @ "<<right<<endl;
            if(condition(mid,lcm1,lcm2,lcm3,lcm4,a,b,c,n))
                right=mid;
            else
                left=mid+1;
        }
        return left;
        
    }
};

2nd ques:

class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& v, int startPos, int k) {
        unordered_map<int,int> m;
        for(auto i:v)m[i[0]]=i[1];
         int sum1=m[startPos];
        for(int i=startPos+1;i<=k+startPos;i++)
            sum1+=m[i];
         int res=sum1;
        int left=startPos-1,right=startPos+k;
        while(left>=0&&left<right)
        {
            res=max(res,sum1);
            sum1-=m[right];
            right--;
            sum1-=m[right];
            right--;
            sum1+=m[left];
            left--;
        }
            res=max(res,sum1);
            sum1=m[startPos],left=startPos-k,right=startPos+1;
            for(int i=startPos-1;i>=startPos-k;i--)
               sum1+=m[i];
        
          while(right<=v.back()[0]&&left<right)
           {
               res=max(res,sum1);
               sum1-=m[left];
               left++;
               sum1-=m[left];
               left++;
               sum1+=m[right];
               right++;
           }
            res=max(res,sum1);
        return res;
        
    }
};
Arpit
solution 1st question:-
class Solution {
public:
 int nthUglyNumber(int n, int a, int b, int c) {
       int start=1;
        int end=a*n;
        long int ab=(long int)a*b/gcd(a,b);
      long  int bc=(long int)c*b/gcd(c,b);
        long int ca=(long int)a*c/gcd(a,c);
         long int abc=(long int)a*bc/gcd(a,bc);
        while(start<end){
            int mid=start+(end-start)/2;
           int total=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ca+mid/abc;
           cout<<total<<" ";
            if(total<n){
                start=mid+1;
            }
            else
                end=mid;
        }
        return end;
    }
};
solution 3rd question:-
class Solution {
public:
     vector<string> v={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    
    vector<string> lc(string s){
          vector<string>m;
        if(s.length()==0){
            m.push_back(""); 
            return m;
        }
        char ch=s[0];
        string sub=s.substr(1);
         m=lc(sub);
        vector<string>res;
        string rstr=v[ch-'0'];
        for(int i=0;i<rstr.length();i++){
            char cha =rstr[i];
            for(string c:m){
                res.push_back(cha+c);
            }
        }
        return res;
    }
    
    vector<string> letterCombinations(string s) {
        vector<string> res;
        if(s.size()==0) return res;
         res=lc(s);
        return res;
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------


<<<<<<< HEAD
Ashish->
https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
=======

Date:13/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/partition-equal-subset-sum/
Arpit -> https://leetcode.com/problems/path-sum-iii/
Ashish -> https://leetcode.com/problems/zigzag-conversion/
Karan -> https://leetcode.com/problems/construct-string-from-binary-tree/
------------------------------------------------------------------------------------------------------------------------------------------------------------

Solutions:

From Gajendra:
1st: 
class Solution {
public:
        struct HASH{
	size_t operator()(const pair<int,int> &x)const{
		return hash<int>()(x.first^x.second);
	}
};
    unordered_map<pair<int,int>,int,HASH> m;
    bool can(int sum,vector<int>&v,int i,int req)
    {
        if(i>=v.size())
            return false;
        if(sum==req)
            return true;
        if(sum>req)
            return false;
        
        if(m.find({i,sum})!=m.end())
            return m[{i,sum}];
        
        return m[{i,sum}]=can(sum+v[i],v,i+1,req)||can(sum,v,i+1,req);
    }
    
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(auto i:nums)sum+=i;
        if(sum%2==0)
        {
            sum/=2;
            if(can(0,nums   ,0,sum))
                return true;
        }            
        return false;
    }
};
2nd:
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows==1)
            return s;
        bool decreasing=false;
        vector<vector<char>>v;
        for(int i=0;i<numRows;i++)
        {
            vector<char> temp;
            for(int j=0;j<s.length();j++)
            {
              temp.push_back(' ');  
            }
            v.push_back(temp);
        }
        int row=0,col=0;
        for(auto i:s)
        {
            if(decreasing)
            {
                col++;
                v[row][col]=i;
                row--;
                if(row<=0)
                {decreasing=false;row=0;col++;}
            }
            else
            {
                v[row][col]=i;
                if(row==numRows-1)
                {
                    decreasing=true;row--;
                }
                else
                    row++;
                if(row==0)
                {
                    decreasing=false;col++;
                }
            }
        }
        string res;
        for(auto i:v)
        {
            for(auto j:i)
            {
                // cout<<j<<" ";
                if(j!=' ')
                res.push_back(j);
            }
            // cout<<endl;
        }
        return res;
    }
};
3rd:


class Solution {
public:
    
    void solve(TreeNode* root,int targetSum,map<int,int> m,int &res,int currSum)
    {
        if(root==NULL)
            return;
        currSum+=root->val;
        
        int req=currSum-targetSum;
        
        if(m.find(req)!=m.end())
            res+=m[req];
        
        m[currSum]++;
        
        solve(root->left,targetSum,m,res,currSum);
        solve(root->right,targetSum,m,res,currSum);
    }
    
    int pathSum(TreeNode* root, int targetSum) {
        int res=0;
        map<int,int> m;
        m[0]=1;
        solve(root,targetSum,m,res,0);
        return res;
    }
};


4th:

class Solution {
public:
    void t(TreeNode* r,string &res)
    {
        if(!r)
            return;

        stringstream ss;
        ss<<r->val;
        string num;ss>>num;
        
        res+=num;
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back('(');
        
        t(r->left,res);     
        
        if(!(r->left==NULL&&r->right==NULL))
        res.push_back(')');
        
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back('(');

        t(r->right,res); 
        if((r->left==NULL&&r->right==NULL)||(r->left!=NULL&&r->right==NULL))
        {
            
        }
        else
        res.push_back(')');
        
    }
    
    string tree2str(TreeNode* root) {
        string res;
        t(root,res);
        return res;
        
    }
};



Arpit's
solution ques2:-
class Solution {
public:
    int ct=0;
    int p=1;
    void func(TreeNode* root,int s){
        if(root==NULL) return ;
        if(root->val==s){ ct++;}
        func(root->left,s-root->val);
        func(root->right,s-root->val);
    }
    void helper(TreeNode* root,int targetSum){
        if(root==NULL) return;
         func(root->left,targetSum);
         func(root->right,targetSum);
        helper(root->left,targetSum);
        helper(root->right,targetSum);        
    }
    int pathSum(TreeNode* root, int targetSum) {
       if(root==NULL) return 0;
        if(p) {
             func(root,targetSum);
            p=0;
        }
       helper(root,targetSum);
        return ct;
    }
};






From Ashish
gajendra que's soln
bool check(vector<int>&nums, int sum, int n,vector<vector<int>>&dp){
    if(sum<0){
        return false;
    }
    if(sum==0){
        return true;
    }
    if(n==0){
        return false;
    }
    if(dp[sum][n]!=-1){
        return dp[sum][n];
    }
    bool x = check(nums, sum-nums[n-1],n-1,dp);
    bool y = check(nums, sum, n-1,dp);
    dp[sum][n] = (x|y);
    return dp[sum][n];
    
}

class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto x: nums){
            sum+=x;
        }
        if(sum&1){
            return false;
        }
        sum/=2;
        
        vector<int>dpp(nums.size()+1,-1);
        vector<vector<int>> dp(sum+1,dpp);
        return check(nums,sum,nums.size(),dp);
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------



Date: 14/12/2021

Questions:
Gajendra-> https://leetcode.com/problems/range-sum-of-bst/
Arpit-> https://leetcode.com/problems/delete-node-in-a-bst/
Karan -> https://leetcode.com/problems/my-calendar-i/
Ashish-> https://leetcode.com/contest/biweekly-contest-66/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/


---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra
1st :
class Solution {
public:
    int res=0;
    void traverse(TreeNode* r,int low,int high)
    {
        if(r==NULL)
            return;
        if(r->val>=low&&r->val<=high)
            res+=r->val;
        if(r->val>=low&&r->val<=high)
        {
            traverse(r->left,low,high);
            traverse(r->right,low,high);
        }
        else if(r->val<low)
            traverse(r->right,low,high);
        else if(r->val>high)
            traverse(r->left,low,high);

    }
    int rangeSumBST(TreeNode* root, int low, int high) {
        traverse(root,low,high);
        return res;
    }
};

2nd:
class Solution {
public:
    TreeNode* findMin(TreeNode* r)
    {
        while(r->left!=NULL)    
            r=r->left;
        return r;
    }
    void del_node(TreeNode* &r,TreeNode*  d)
    {
        if(r==NULL)return;
        if(r->left==d)
        {
            
            r->left=r->left->right;
            return;
        }
      if(r->right==d)
        {
            r->right=r->right->right;
            return;
        }
        del_node(r->left,d);
        del_node(r->right,d);
        
    }
    void dn(TreeNode* &r,int k,TreeNode* tab)
    {
        if(r==NULL)
            return;
        
        if(r->val==k)
        {
            if(r->left==NULL&&r->right==NULL)
            {
              //leaf node
                // del_node(tab,r);
                r=r->right;
                return;
            }
            else if(r->right==NULL&&r->left!=NULL)
            {
                r=r->left;
                return;
            }
            TreeNode* temp=(findMin(r->right));
            cout<<temp->val;
            TreeNode* gp=temp;
            del_node(r,temp);
            r->val=gp->val;
            return;
        }
        dn(r->left,k,tab);
        dn(r->right,k,tab);
        
    }
    
    TreeNode* deleteNode(TreeNode* root, int key) {
        
        if(root==NULL)
            return root;
        
        if(root->val==key&&root->left==NULL&&root->right==NULL)
            return NULL;

        dn(root,key,root);
        
        return root;
        
    }
};
3rd:
class MyCalendar {
    map<int, int>bookings;
public:    
    bool book(int s1, int e1) {
        
        for(auto  i: bookings) 
        {
            int s2=i.first;
            int e2=i.second;
            if( s1 < e2 && s2 < e1 )   
			    return false; 
        }
        bookings[s1] = e1;                
        return true;
    }
};




Arpit's solution 2nd question:-
class Solution {
public:
    TreeNode* minvalright(TreeNode* root){
        while(root->left){
            root=root->left;
        }
        return root;
    }
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root==NULL) return root;
        if(key<root->val){
            root->left=deleteNode(root->left,key);
        }
        else if(key>root->val){
            root->right=deleteNode(root->right,key);
        }
        else{
            TreeNode* temp=NULL;
            if(root->left==NULL){
                temp=root->right;
                delete root;
                return temp;
            }
            else if(root->right==NULL){
                temp=root->left;
                delete root;
                return temp;
            }
            else{
             temp=minvalright(root->right);
            root->val=temp->val;
            root->right=deleteNode(root->right,temp->val);
            }
        }
        return root;
    }
};


-----------------------
Ashish : Gajendra que soln:
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
void finder(TreeNode* root, int &sum,int low, int max){
    
    if(root==NULL){return;}
    if(root->val>=low && root->val<=max){
        sum+=root->val;
    }
    if(root->val>=max){
       finder(root->left,sum,low,max); 
    }
    else if(root->val<=low){
        finder(root->right,sum,low,max);
    }
   
   else{
       finder(root->left,sum,low,max);
       finder(root->right,sum,low,max);
   }
    
    
}
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        int sum = 0;
        finder(root,sum,low,high);
        return sum;
    }
};


ASHISH : arpit's que
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    int minFinder(TreeNode* root){
       
        int tt = root->val;
        while(root){
            tt = min(tt,root->val);
            root = root->left;
        }
        return tt;
    }
    TreeNode* deleteNode(TreeNode* &root, int key) {
        if(root==NULL){return NULL;}
        if(root->val==key && root->right==NULL){
            return root->left;
        }
        if(root->val==key && root->left==NULL){
            return root->right;
        }
        if(root->val==key){
            int pending = minFinder(root->right);
            root->val = pending;
            root->right = deleteNode(root->right,pending);
            return root;
        }
        
        if(root->val>key){
            root->left = deleteNode(root->left,key);
            return root;
        }
          root->right = deleteNode(root->right,key);
          return root;
        
    }
};
---------------------------------------------------------------------------------------------------------------------------------------------------------------
<<<<<<< HEAD


Date: 15/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/insertion-sort-list/
Karan -> https://leetcode.com/problems/fraction-to-recurring-decimal/

ASHISH: 
https://leetcode.com/contest/weekly-contest-267/problems/time-needed-to-buy-tickets/

<<<<<<< HEAD



OLD QUE  OF KARAN
my calender 1 soln from ashish

class MyCalendar {
public:
    // just a map to take care of interval of prev books
    map<int,int> track;
    MyCalendar() {
        
    }
    
//     try to understand this concept like if there are two intervals like   7----->10  and 2--------->10 so its beneficial to take 2-----> 10 in track map since 7 lies between them so track map has key as ending of event and value as minimum time of beginnig of event 
    
    
    
    
    bool book(int start, int end) {
        end--;
        for(auto x: track){
            if(x.first>=start){
//                checking any interval found with which given slot is overlapping or not 
                    if(x.second<=end){
                        return false;
                    }
                
            }
        }
        
        // here we are checking ending time is already in track map in that case we will just try to minimise the beginning time 
        if(track.find(end)!=track.end()){
            track[end] = min(start,track[end]);
        }
        else{
            track[end] = start;
        }
        return true;
        
        
    }
};

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */






Date: 17/12/2021

Questions: 

Gajendra -> https://leetcode.com/problems/maximal-square/
Karan -> https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
<<<<<<< HEAD
=======


------------------------------------------------------------------------------------------------------------------------------------------

Solution:

2nd ques(Karan):
class Solution {
public:
    int minAddToMakeValid(string s) {
        int gp=0,res=0;
        for(auto i:s)
        {
            if(i=='(')
                gp++;
            else
            {
               
                if(gp<=0)
                    res++;
                else
                     gp--;
            }
        }
        return res+gp;
    }
};

------------------------------------------------------------------------------------------------------------------------------------------


18 dec 

questions:

ASHISH -> https://leetcode.com/problems/container-with-most-water/


------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Gajendra
1st quest:
class Solution {
public:
    int maxArea(vector<int>& v) {
        int left=0,right=v.size()-1;
        int maxx=0;
        while(left<=right)
        {
            int quantity=(right-left)*(min(v[left],v[right]));
            if(v[left]<=v[right])
                left++;
            else

                right--;
            maxx=max(quantity,maxx);
        }
        return maxx;
    }
};


_------------------------------------------------------------------------------------------------------------------------------------------------




Date:19/12/2021

Questions:
Gajendra-> https://leetcode.com/contest/weekly-contest-272/problems/minimum-operations-to-make-the-array-k-increasing/
	  Hints: b)  https://www.geeksforgeeks.org/longest-monotonically-increasing-subsequence-size-n-log-n/
		 a)  https://www.geeksforgeeks.org/convert-to-strictly-increasing-integer-array-with-minimum-changes/
------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:
1)
class Solution {
public:
  
int CeilIndex(vector<int>& v, int l, int r, int key)
{
    return upper_bound(v.begin(),v.begin()+r,key)-v.begin();
}
 
int lis(vector<int>& v)
{
    if (v.size() == 0)
        return 0;
 
    vector<int> tail(v.size(), 0);
    int length = 1; // always points empty slot in tail
 
    tail[0] = v[0];
    for (size_t i = 1; i < v.size(); i++) {
 
        // new smallest value
        if (v[i] < tail[0])
            tail[0] = v[i];
 
        else if (v[i] >= tail[length - 1])
            tail[length++] = v[i];
 
        else
            tail[CeilIndex(tail, 0, length - 1, v[i])] = v[i];
    }
 
    return length;
}
    
    int kIncreasing(vector<int>& arr, int k) {
     
        int n=arr.size(),res=0;
        for(int i=0;i<k;i++)
        {
            vector<int> v;
            for(int j=i;j<n;j+=k)
                v.push_back(arr[j]);
            res+=v.size()-lis(v);
        }
        return res;
        
    }
};

----------------------------------------------------------------------------------------------------------------------------------------------


Date:20/12/2021

Questions:

Gajendra->https://leetcode.com/problems/decode-string/
Ashish -> https://leetcode.com/problems/3sum-closest/description/
Karan -> https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/
---------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

Gajendra:
1) 
class Solution {
public:
    string tmp(string s,int &i)
    {
        string res="";
        if(i>=s.length())
            return res;
        while(i<s.length())
        {
            if(isalpha(s[i]))
               res.push_back(s[i]);
             else if(s[i]==']')
               return res;
              else if(isdigit(s[i]))
               {
                   string num="";
                   while(isdigit(s[i]))
                       num.push_back(s[i++]);
                   stringstream ss;
                   ss<<num;int n;ss>>n;
                   string ans=tmp(s,++i);
                   for(int j=0;j<n;j++)
                       res+=ans;
                  cout<<ans<< n <<res<<endl;
               }
               i++;
        }
        return res;
    }
    string decodeString(string s) {
        int i=0;
        return tmp(s,i);
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------
Date : 21/12/2021

Questions:

Karan-> https://leetcode.com/problems/power-of-two/
Gajendra -> https://leetcode.com/problems/merge-intervals/


---------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter: karan

class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n>0?!(n&(n-1)):false;
    }
};

Setter: Gajendra

class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
       sort(intervals.begin(),intervals.end());
        vector<vector<int>>res;
        res.push_back({intervals[0][0],intervals[0][1]});
        for(int i=1;i<intervals.size();i++)
        {
            if(res.back()[1]>=intervals[i][0])
                res.back()[1]=max(res.back()[1],intervals[i][1]);
            else
                res.push_back({intervals[i][0],intervals[i][1]});
        }
        return res;
    }
};

Solver: Gajendra
Setter: Ashish
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> res{nums[0]};
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i]>res.back())
                res.push_back(nums[i]);
            else
            {
                auto ind=lower_bound(res.begin(),res.end(),nums[i])-res.begin();
                res[ind]=nums[i];
            }
        }
        return res.size();
    }
    
};


-----------------------------------------------------------------------------------------------------------------------------------------------------


Questions from Ashish:
https://leetcode.com/problems/longest-increasing-subsequence/

------------------------------------------------------------------------





Date : 22/12/2021

Questions:

Gajendra-> https://leetcode.com/problems/design-hashmap/submissions/ 
Karan -> https://leetcode.com/problems/reorder-list/submissions/



----------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra

class MyHashMap {
public:
    int arr[1000001];
    MyHashMap() {
    for(int i=0;i<1000001;i++)
      arr[i]=-1;
    }
    
    void put(int key, int value) {
        arr[key]=value;
    }
    
    int get(int key) {
        return arr[key];
    }
    
    void remove(int key) {
        arr[key]=-1;
    }
};


-----------------------------------------------------------------------------------------------------------------------------------------------------

ASHISH's que :

https://leetcode.com/problems/group-anagrams/submissions/


SOLVER : ASHISH
SETTER : ASHISH

class Solution {
public:
  // map for storing value as arr of  strings which is anagrams of key 
  map<string,vector<string>> str_store; 
    
//  here making  a function that takes string s in addition to str_store(defined above)
//     it will make a copy of string s as t after that it will sort that then just map....
void  checker(map<string,vector<string>> &str_store,string s){
    string t = s;
    sort(t.begin(),t.end());
   str_store[t].push_back(s);  
}
       
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
//         iterating over all strings  and then  appling checker function (explained above)
        for(auto x: strs){
            checker(str_store,x);
        }
// now returning vector of vector  as answer
        vector<vector<string>> ans;
        for(auto x: str_store){
            ans.push_back(x.second);
        }
        
        
        return ans;
    }
};




QUE FROM ASHISH
https://leetcode.com/problems/course-schedule-ii/
Solution from Gajendra for course-schedule-ii:
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& v) {
            map<int, vector<int>> g;
            map<int, int> indegree;
        for(auto i:v)
        {
            indegree[i[0]]++;
            g[i[1]].push_back(i[0]);
        }
        vector<int> res;
        int vis_count = 0;
        deque<int> dq;
        for (int i = 0; i <numCourses; i++)
            if (indegree[i] == 0)
                dq.push_back(i);
        while (dq.size())
        {
            auto u = dq.front();
            dq.pop_front();
            cout<<u;
            res.push_back(u);
            vis_count++;
            for (auto v : g[u])
            {
                indegree[v]--;
                if (indegree[v] == 0)
                    dq.push_back(v);
            }
        }
        if(vis_count!=numCourses)
            return {};
        return res;
    }
};







Date : 24/12/2021

Questions :

Karan -> https://leetcode.com/problems/min-stack/
Gajendra -> https://leetcode.com/problems/palindromic-substrings/
ASHISH -> https://leetcode.com/problems/integer-to-roman/submissions/




--------------------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra

class Solution {
public:
    int countSubstrings(string s) {
        int res=0;
        for(int i=0;i<s.length();i++)
        {
            int left=i-1,right=i+1;
            res++;
            while(left>=0&&right<s.length()&&s[left--]==s[right++])res++;
            left=i,right=i+1;
            while(left>=0&&right<s.length()&&s[left--]==s[right++])res++;
        }
        return res;
    }
};

Solver:Gajendra
Setter:Karan

class MinStack:
    
    def __init__(self):
        self.stack=[]
        self.minn=2**31+1

    def push(self, val: int) -> None:
        self.minn=min(self.minn,val)
        self.stack.append((val,self.minn))

    def pop(self) -> None:
        self.stack.pop()
        if len(self.stack)==0:
            self.minn=2**31+1
        else:
            self.minn=self.stack[-1][1]

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        return self.stack[-1][1]
	
	
Solver:Arpit
Setter:Aashish
class Solution {
public:
    string intToRoman(int num) {
    string M[] = {"", "M", "MM", "MMM"};
    string C[] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
    string X[] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    string I[] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];
    }
};

---------------------------------------------------------------------------------------------------------------------------------------------------------------


Date:25/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/course-schedule/
Arpit -> https://leetcode.com/problems/regular-expression-matching/
Gajendra -> https://leetcode.com/problems/find-eventual-safe-states/submissions/
Karan -> https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

Solver->Arpit
Setter->Arpit
class Solution {
public:
    bool isMatch(string s, string p) {
      if(p.length()==0){
          return s.length()==0;
      } 
      if(p.length()>1 && p[1]=='*'){
          if(isMatch(s,p.substr(2))){
              return true;
          }
          if(s.length()>0 && (s[0]==p[0] || p[0]=='.')){
             return isMatch(s.substr(1),p);
          }
          return false;
      }
        else{
            if(s.length()>0 && (s[0]==p[0] || p[0]=='.')){
               return isMatch(s.substr(1),p.substr(1));
            }
                return false; 
        }
        return true;
    }
};

Solver -> Gajendra
Setter ->Gajendra

class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& v) {
            map<int, vector<int>> g;
            map<int, int> indegree;
        for(auto i:v)
        {
            indegree[i[0]]++;
            g[i[1]].push_back(i[0]);
        }
        int vis_count = 0;
        deque<int> dq;
        for (int i = 0; i <numCourses; i++)
            if (indegree[i] == 0)
                dq.push_back(i);
        while (dq.size())
        {
            auto u = dq.front();
            dq.pop_front();
            cout<<u;
            vis_count++;
            for (auto v : g[u])
            {
                indegree[v]--;
                if (indegree[v] == 0)
                    dq.push_back(v);
            }
        }
        if(vis_count==numCourses)
            return true;
        return false;
    }
};

Setter -> Gajendra
Solver -> Gajendra

class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
           map<int, vector<int>> g;
            map<int, int> indegree;
        
            for(int i=0;i<graph.size();i++)
            {
                for(auto j:graph[i])
                {
                    g[j].push_back(i);
                    indegree[i]++;
                }
            }
            vector<int> res;
            deque<int> dq;
            for (int i = 0; i <graph.size(); i++)
                if (indegree[i] == 0)
                    dq.push_back(i);
            while (dq.size())
            {
                auto u = dq.front();
                dq.pop_front();
                res.push_back(u);
                for (auto v : g[u])
                {
                    indegree[v]--;
                    if (indegree[v] == 0)
                        dq.push_back(v);
                }
            }
            sort(res.begin(),res.end());
            return res;
    }
};


---------------------------------------------------------------------------------------------------------------------------------------------------------------


Date: 26/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/recover-the-original-array/
Karan -> https://leetcode.com/problems/k-closest-points-to-origin/

--------------------------------------------------------------------------------------------------
Solutions:

Solver -> Gajendra
Setter ->Gajendra

class Solution {
public:
    vector<int> recoverArray(vector<int>& nums) {
        vector<int> k;
        sort(nums.begin(),nums.end());
        int child=nums[0];
        for(auto i:nums)
        {
            int x=i-child;
            if(x%2==0&&x!=0)
            k.push_back(x/2);
        }
        int res=0;
        for(auto kk:k)
        {
          unordered_map<int,int> m;
            for(auto i:nums)
                m[i]++;
            for(auto i:nums)
            {
                if(m.find(i)!=m.end())
                m[i]--;
                else
                continue;
               
                if(m.find(i+2*kk)!=m.end())
                    m[i+2*kk]--;
                else
                    break;
               if(m[i]==0)m.erase(i);
                if(m[i+2*kk]==0)
                    m.erase(i+2*kk);
            }
            if(m.size()==0)
            {
             res=kk;break;
            }
        }
        vector<int>result;
         unordered_map<int,int> m;
            for(auto i:nums)
                m[i]++;
             for(auto i:nums)
            {
             if(m.find(i)!=m.end())
             {m[i]--;result.push_back(i+res);}
                else
                continue;
                if(m[i]==0)m.erase(i);
                if(m.find(i+2*res)!=m.end())
                    m[i+2*res]--;
                else
                    continue;
                if(m[i+2*res]==0)
                    m.erase(i+2*res);
            }
        return result;
    }
};

Solver -> Gajendra
Setter -> Karan

class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        map<int,vector<vector<int>>> m;
        for(auto i:points)
        {
            int x=i[0],y=i[1];
            int gp=x*x+y*y;
            m[gp].push_back({x,y});
        }
        vector<vector<int>> res;
        for(auto i:m)
        {
            for(auto j:i.second)
            {
                k--;res.push_back({j[0],j[1]});
            }
            if(k==0)
                break;
        }
        return res;
    }
};


----------------------------------------------------------------------------------------------------



Date: 27/12/2021

Questions:

Gajendra -> https://leetcode.com/problems/basic-calculator-ii/
Karan -> https://leetcode.com/problems/number-complement/


Date: 28/12/2021
Questions:

Gajendra -> https://leetcode.com/problems/find-peak-element/      -> O(logn)
Karan -> https://leetcode.com/problems/middle-of-the-linked-list/



------------------------------------------------------------------------
Solutions:

Solver:Gajendra
Setter:Gajendra
class Solution {
public:
    int findPeakElement(vector<int>& v) {

        int l=0,r=v.size()-1;
        while(l<r)
        {
            int mid=(l+r)/2;
            if(v[mid]>v[mid+1])
                r=mid;
            else
                l=mid+1;
        }
        return l;
    }
};







------------------------------------------------------------------------



Today's question by ashish
https://leetcode.com/problems/surrounded-regions/submissions/




Soln for ashish que by ashish 



class Solution {
public:
    
  
void deadCatcher(int i , int j , vector<vector<char>> &board, set<vector<int>> &dead, set<vector<int>> &visited){
        
int row = board.size();
    
int col = board[0].size();
    
    
//     just a dfs to reach connected zero's position
    if(i>=row || i<0 || j>=col || j<0 || board[i][j]=='X'){return;}
    
    if(visited.find({i,j})!=visited.end()){return;}
    dead.insert({i,j});
    visited.insert({i,j});
    deadCatcher(i+1,j,board,dead,visited);
    deadCatcher(i-1,j,board,dead,visited);
    deadCatcher(i,j+1,board,dead,visited);
    deadCatcher(i,j-1,board,dead,visited);
  
        
        
    }
    
    void solve(vector<vector<char>>& board) {
        
//         hey hello ashish is here 
//         so direct soln is to  carry all zeroes which is on border or connected to any border zero whether through right, left, up, down direction so after carry all that zeroes's positions in suitable data-struct we have to just
//         iterate on all zeroes's position of given board and make that equal to 'X' only if that zero's postion  is not in that data-struct (in this soln i have used set of vector)
        

        
        
        
        
//         now i will be contuing with finding all that zeroes that are on border or...... for that purpose i will use dfs so visited set is for tell whether i am repeating or not 
//          see more in dfs fucntion named as deadCatcher 
        set<vector<int>> dead;
        set<vector<int>> visited;
        int row = board.size();
    int col = board[0].size();
        
        
        
        
//          begining dfs call to that position only which is already on border so that using dfs we can get all postiion which is connected to that
        for(int i =0; i<board.size(); i++){
            
            for(int j =0; j<board[0].size(); j++){
                if(board[i][j]=='O' && (i==0 || i==row-1 || j==0 || j==col-1)){
                    deadCatcher(i,j,board,dead,visited);
                }
            }
            
            
        }
        
        
        
//         after finding all zeroes'position which is connected to border zero we can apply our second step to flip that zero's position which is not in that set which is named as dead set
        
        
                for(int i =0; i<board.size(); i++){
            
            for(int j =0; j<board[0].size(); j++){
                if(board[i][j]=='O' && (dead.find({i,j})==dead.end())){
                    board[i][j] = 'X';
                }
            }
            
            
        }
        
      
        
        
    }
};


--------------------------------------------------------




1
Date: 29/12/2021

Questions:
Gajendra->https://leetcode.com/problems/3sum/
Karan -> https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
Ashish -> https://leetcode.com/problems/reverse-nodes-in-k-group/


------------------------------------------------------------------------------

Solutions:
Solver:Gajendra
Setter:Gajendra
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int a=0;a<nums.size();a++)
        {
            if(a>0&&nums[a]==nums[a-1])
                continue;
            int low=a+1,high=nums.size()-1;
            int req_sum=-nums[a];
            while(low<nums.size()-1&&high>0&&low<high)
            {
                int bPlusc=nums[low]+nums[high];
                if(bPlusc>-nums[a])
                {
                    high--;
                }
                else if(bPlusc<-nums[a])
                {
                    low++;
                }
                else if(bPlusc+nums[a]==0)
                {
                    res.push_back({nums[a],nums[low],nums[high]});
                    cout<<nums[a]<<" "<<nums[low]<<" "<<nums[high]<<endl;
                    low++;
                    while(low<nums.size()-1&&nums[low]==nums[low-1])
                        low++;
                    high--;
                    while(high>0&&nums[high]==nums[high+1])
                        high--;
                }
            }
        }
        return res;
    }
};

Solver:Gajendra
Setter:Karan
class FindElements {
public:

    map<int,bool>m;
    void traverse(int x,TreeNode* &root)
    {
        if(root==NULL)return;
        root->val=x;
        m[x]=true;
        traverse(2*x+1,root->left);
        traverse(2*x+2,root->right);
    }
    FindElements(TreeNode* root) {
        traverse(0,root);
    }
    
    bool find(int target) {
        return m[target];
    }
};



-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


Date: 30/12/2021
Questions:
Gajendra -> https://leetcode.com/problems/interval-list-intersections/
Karan -> https://leetcode.com/problems/smallest-integer-divisible-by-k/
Arpit-> https://leetcode.com/problems/coin-change-2/
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
solver-Arpit
setter-Arpit
class Solution {
public:
    int dp[301][5001];
    int helper(vector<int>&coins,int amount,int n){
        if(n==0 || amount==0){
            return amount==0?1:0;
        }
        if(dp[n][amount]!=-1){
            return dp[n][amount];
        }
        if(coins[n-1]<=amount){
            return dp[n][amount]=(helper(coins,amount-coins[n-1],n)+helper(coins,amount,n-1));
        }
            return dp[n][amount]=helper(coins,amount,n-1);
    }
    int change(int amount, vector<int>& coins) {
        memset(dp,-1,sizeof(dp));
       int res=helper(coins,amount,coins.size());
        return  res;
    }
};

solver-Arpit
setter-Karan
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        if(k%2==0 || k%5==0){
            return -1;
        }
        int rem=0;
      for(int i=1;i<=k;i++){
          rem=((rem*10)+1)%k;
          if(rem%k==0){
              return i;
          }
      }
        return -1;
    }
};

solver-Arpit
setter-Gajendra
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& first, vector<vector<int>>& second) {
         int i=0,j=0;
        vector<vector<int>>ans;
        while(i<first.size() && j<second.size()){
            vector<int>v;
           v.push_back(max(first[i][0],second[j][0]));
           v.push_back(min(first[i][1],second[j][1]));
           if(v[0]<=v[1])
           ans.push_back(v);
           if(first[i][1]<second[j][1]){
               i++;
           }
            else if(first[i][1]==second[j][1]){
                i++; j++;
            }
            else{
                j++;
            }
        }
        return ans;
    }
};

Solver: Gajendra
Setter: Karan
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        if(k%2==0 || k%5==0)
            return -1;
        
        int len=1;
        int num=1;
        while(num%k!=0)
        {
            len++;
            num=(num%k)*10+1;
        }
        return len;
    }
};


SOLVER : ASHISH
GIVER: GAJENDRA

SOLN:
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& f, vector<vector<int>>& s) {
//         leaving points of a
        set<int> a_leaving_points;
        set<int> b_leaving_points;
        
        set<int> store;
        for(auto x:f){
            store.insert(x[0]);
            store.insert(x[1]);
            a_leaving_points.insert(x[1]);
        }
        
       
         for(auto x:s){
            store.insert(x[0]);
            store.insert(x[1]);
            b_leaving_points.insert(x[1]);
        }
    map<int,vector<int>> mapping;
     for(auto x: store){
         mapping[x] = {0,0};
     }
    for(auto x:f){
mapping[x[0]][0]++;
mapping[x[1]][0]--;
    }
        
        
        for(auto x:s){
mapping[x[0]][1]++;
mapping[x[1]][1]--;
    }    
        

        int pre1 = 0;
        int pre2 = 0;
        for(auto x: mapping){
            int t = x.first;
            vector<int> v = x.second;
            v[0]+=pre1;
            pre1 = v[0];
            v[1]+=pre2;
            pre2 = v[1];
            mapping[t] = v;
            
        }
    
        
     vector<vector<int>> ans;
        int process = -1;
        for(auto x: mapping){
            vector<int> v = x.second;
            if(v[0]+v[1]==2){
                process = x.first;
                continue;
            }
            
            
            int a = v[0];
            int b = v[1];
            if(a_leaving_points.count(x.first)){
                a++;
            }
            if(b_leaving_points.count(x.first)){
                b++;
            }
            if(a+b==2){
                if(process!=-1){
                    ans.push_back({process,x.first});
                    process = -1;
                }
                else{
                    ans.push_back({x.first,x.first});
                }
            }
            
            
            
        }
        
        
      return ans;  
        
        
    }
};
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Date:31/12/2021
Questions:
Karan -> https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/
Gajendra -> https://leetcode.com/problems/backspace-string-compare/
---------------------------------------------------------------------------------------
Solutions:

solver-Arpit
setter->Karan
class Solution {
public:
    int maxAncestorDiff(TreeNode* root,int mn=100000,int mx=0) {
       if(root==NULL){
           return mx-mn;
       }
        mx=max(mx,root->val);
        mn=min(mn,root->val);
        return max(maxAncestorDiff(root->left,mn,mx),maxAncestorDiff(root->right,mn,mx));
    }
};

Solver:Gajendra
Setter:Karan
class Solution {
public:
    int calc(TreeNode* r,int maxx,int minn)
    {
        if(r==NULL)return maxx-minn;
        maxx=max(maxx,r->val);
        minn=min(minn,r->val);
        
        return max(calc(r->left,maxx,minn),calc(r->right,maxx,minn));
    }
    
    int maxAncestorDiff(TreeNode* root) {
    return calc(root,INT_MIN,INT_MAX);
}
};
---------------------------------------------------------------------------------------------
