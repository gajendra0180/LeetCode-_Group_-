Date:10/12/2021
Gajendra -https://leetcode.com/problems/merge-intervals/
Gajendra- https://leetcode.com/problems/sort-colors/submissions/
Karan -https://leetcode.com/problems/longest-substring-without-repeating-characters/
ASHISH - https://leetcode.com/problems/next-permutation/

----------------------------------------------------------


//ASHISH
//first soln
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& v) {
        if(v.size()==1){return v;}
      sort(v.begin(),v.end());
        vector<vector<int>> ans;
        ans.push_back(v[0]);
        for(int i = 1; i<v.size(); i++){
            
            if(ans.back()[1]<v[i][0]){
                ans.push_back({v[i][0],v[i][1]});
            }
            else{
                int new_first = ans.back()[0];
                int new_second = max(ans.back()[1],v[i][1]);
                ans.pop_back();
                ans.push_back({new_first,new_second});
            }
            
            
        }
        return ans;
    }
};

//2nd soln

class Solution {
public:
    void sortColors(vector<int>& nums) {
    int zero = 0;
    int one = 0;
    int two = 0;
    for(auto x: nums){
        if(x==0){zero++;}
        else if(x==1){one++;}
        else{two++;}
    }
    for(int i =0; i<nums.size(); i++){
        if(zero){
            nums[i] = 0;
            zero--;
        }
        else if(one){
            nums[i] = 1;
            one--;
        }
        else{
            nums[i] = 2;
            two--;
        }
    }

    }
};



//3rd solution

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
       if(s.length()==0 || s.length()==1){
           return s.length();
       }
        
        map<char,int> store;
        for(int i =0; i<s.length();i++){
            store[s[i]] = i;
        }
       
     
        vector<int>ans;
        for(int i =0; i<s.length();i++){
            ans.push_back(0);
        }
        ans[s.length()-1] = 1;
        for(int i = s.length()-2;i>=0;i--){
            if(store[s[i]]>i){
                
             int xx = store[s[i]]-i;
             int yy = ans[i+1]+1;
                ans[i] = min(xx,yy);
                store[s[i]] = i;
            }
            else if(store[s[i]]<=i){
                ans[i]=ans[i+1]+1;
                
                 store[s[i]] = i;
                
            }
        }
        sort(ans.begin(),ans.end());
        return ans[ans.size()-1];
        
    }
};

-------------------------------------------------------------------




Dated: 11/12/2021


Questions:
Gajendra-https://leetcode.com/problems/nth-magical-number/
Arpit- https://leetcode.com/problems/count-complete-tree-nodes/submissions/
Karan - https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/

Ashish-
https://leetcode.com/problems/swap-nodes-in-pairs/





Solutions:

----------------------------------------------------------------------------

Ashish:
my que soln:
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
       if(head==NULL || head->next==NULL){
           return head;
       } 
        
        ListNode* pre = NULL;
        ListNode* pos = head;
        while(pos!=NULL){
            if(pre==NULL){
                 if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre = pos;
                head = mid;
                pos = st;
            }
            else{
                if(pos->next==NULL){return head;}
                ListNode* st = pos->next->next;
                ListNode* mid = pos->next;
                pos->next->next = pos;
                pos->next = st;
                pre->next = mid;
                pre = pos;
                pos = st;
                
            }
            
            
        }
        return head;
    }
};



Ashish : karan's que ans
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#define tn TreeNode
class Solution {
public:
    TreeNode* recoverFromPreorder(string t) {
        
        int d = 0;
        int v = 0;
        map<tn*,int> map_dist;
        map<tn*,vector<int>> map_allow;
        tn* root = NULL;
        stack<tn*> myset;
    
        for(auto x: t){
          
            if(x!='-'){
                v = v*10+(x-'0');
                
              
               
             
            }
            else{
            
               if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                       continue;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
                
                
                d++;
                
                
                
            }
        }
        
        if(v!=0){
                  
                   tn* nn = new tn(v);
                   map_dist[nn] = d;
                   if(root==NULL){
                       
                       root = nn;
                       myset.push(nn);
                       map_allow[nn] = {1,1};
                       v = 0;
                       d = 1;
                      return root;
                   }
                   
                   while(myset.size()>0 && map_dist[myset.top()]!=d-1){
                       myset.pop();
                   }
                   
              
                   if(map_allow[myset.top()][0]==1){
                       myset.top()->left = nn;
                       map_allow[myset.top()] = {0,1};
                   }
                   else{
                       myset.top()->right = nn;
                       myset.pop();
                   }
                  
                   myset.push(nn);
                   map_allow[nn] = {1,1};
                   d = 0;
                   v = 0;
                   
                   
               } 
                
        return root;
        
        
    }
};

ASHISH: Gajendra que ans
#define ll long long
ll gcd(ll a, ll b){
    if(a==0){return b;}
    if(b==0){return a;}
    return gcd(b, a%b);
}
ll lcm(ll a, ll b){
    return (a*b)/gcd(a,b);
}
class Solution {
public:
    int nthMagicalNumber(int nn, int a, int b) {
        ll aa = (ll)a;
        ll bb = (ll)b;
        ll n = nn;
        ll left = 1;
        ll k = lcm(aa,bb);
        ll right = 1e18;
        ll ans = 1e18;
        while(left<=right){
            ll mid = (left+right)/2;
            ll target = (mid/aa)+(mid/bb)-(mid/k);
            if(target<n){
                left = mid+1;
            }
            else{
                if(target==n){
                    ans = min(ans, mid%(1000000007));
                }
                right = mid-1;
            }
           
        }
       return ans; 
    }
};


Arpit:
Solution 2nd question
class Solution {
public:
    int heightl(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->left;
      }
        return h;
    }
     int heightr(TreeNode* root){
        if(root==NULL)
            return 0;
        int h=0;
      while(root){
          h++;
          root=root->right;
      }
        return h;
    }
    int countNodes(TreeNode* root) {
        if(root==NULL)
            return 0;
        int l=heightl(root);
        int r=heightr(root);
        if(l==r){
          return pow(2,l)-1;
        }
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

Solution 3rd question
class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
        
        map<string,pair<TreeNode*,int>>m;
            int num=0;string v="";
        TreeNode* z=NULL;int x;
        TreeNode* root=NULL;
        for(int i=0;i<s.length();i++){
            if(s[i]>=48 && s[i]<=57){
                 num=0;
                while(i<s.length() && s[i]>=48 && s[i]<=57){
                    num=num*10+(s[i]-48);
                    i++;
                }
                i--;
                  z=new TreeNode(num);
                if(root==NULL)
                    root=z;
                else{
                  root=m[v].first;
                  x=m[v].second;
                    if(x==0){
                        root->left=z;
                    }
                    if(x==1){
                        root->right=z;
                    }
                }
            }
            else{
               int l=v.length();
                 v="";
               while(s[i]=='-'){
                   v.push_back('-');
                   i++;
               }
               int u=v.length();
                i--;
                if(m.find(v)==m.end()){
                    m[v]={z,0};
                }
                else if(m.find(v)!=m.end() && m[v].second!=1){
                    m[v].second++;
                }
                else{
                    m[v]={z,0};
                }
                if(l>u){
                for(auto it=++m.find(v);it!=m.end();it++){
                    (*it).second.second=1;
                }
                }
            }
        }
        if(m.size()==0){
            return z;
        }
        auto pair=m["-"];
        return pair.first;
    }
};



Gajendra:
1st ques:
class Solution {
public:
    
    
    bool condition(long long int mid,long long int req,long long int a,long long int b,long long lcm)
    {
        long long int posx=mid/a+mid/b-(mid/lcm);
        if(posx<req)
            return false;
        return true;
    }
    
    int nthMagicalNumber(int n, int a, int b) {
        long long int gcd=__gcd(a,b);
        long long int lcm=a*b/gcd;
       long long int left=1,right=1e18;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            if(condition(mid,n,a,b,lcm))
                right=mid;
            else
                left=mid+1;
        }
        int mod=1e9+7;
        return left%mod;
    }
};

2nd ques:
class Solution {
public:
    int lheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+lheight(root->left);
    }
    
    int rheight(TreeNode* root)
    {
        if(!root)
            return 0;
        return 1+rheight(root->right);
    }
    int countNodes(TreeNode* root) {
      
        if(!root)return 0;
        
        int l=lheight(root->left);
        int r=rheight(root->right);

        
        if(l==r)
            return pow(2,l+1)-1;
        
        cout<<l<<" "<<r<<endl;
        
        return 1+countNodes(root->left)+countNodes(root->right);
    }
};

3rd question:


class Solution {
public:
    TreeNode* recoverFromPreorder(string s) {
     
        map<int,TreeNode*> m;
        int current_level=0,chk=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]=='-')
                current_level++;
            else
            {
                string num;
                while(i<s.size()&&s[i]>='0'&&s[i]<='9')
                {
                    num.push_back(s[i]);
                    i++;
                }
                
                i--;
                
                stringstream ss;
                ss<<num;
                int n;
                ss>>n;
                
                TreeNode* temp=new TreeNode(n);
                
                m[current_level]=temp;
                
                if(current_level){
                    
                if(m[current_level-1]->left)
                    m[current_level-1]->right=temp;
                else
                    m[current_level-1]->left=temp;
                }
                current_level=0;
            }
        }
        return m[0];
    }
};

-----------------------------------------------------------------------------

<<<<<<< HEAD
=======

>>>>>>> 220a8bba66c07ac446287a9879dd949553d41b73



Date:12/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/ugly-number-iii
Ashish->   https://leetcode.com/contest/weekly-contest-271/problems/maximum-fruits-harvested-after-at-most-k-steps/
Karan-> https://leetcode.com/problems/letter-combinations-of-a-phone-number/

-------------------------------------------------------------------------------------------------------------------------------------------------
Solutions:

1st ques:
class Solution {
public:
    
    bool condition(long long int mid,long long int l1,long long int l2,long long int l3,long long int l4,long long int a,long long int b,long long int c,long long int req)
    {
        long long int n=mid/a+mid/b+mid/c-mid/l1-mid/l2-mid/l3+mid/l4;
        // cout<<mid<<" "<<n<<endl;
        if(n<req)
            return false;
        return true;
    }
    
    int nthUglyNumber(long long int n, long long int a, long long int b, long long int c) {
        long long int left=1,right=1e18;
        long long int lcm1=(a*b)/__gcd(a,b);
        long long int lcm2=(b*c)/__gcd(b,c);
        long long int lcm3=(a*c)/__gcd(a,c);
        long long int lcm4=a*lcm2/(__gcd(a,lcm2));
        // cout<<lcm1<<lcm2<<lcm3<<lcm4<<endl;
        while(left<right)
        {
            long long int mid=left+(right-left)/2;
            // cout<<left<<" @ "<<right<<endl;
            if(condition(mid,lcm1,lcm2,lcm3,lcm4,a,b,c,n))
                right=mid;
            else
                left=mid+1;
        }
        return left;
        
    }
};

2nd ques:

class Solution {
public:
    int maxTotalFruits(vector<vector<int>>& v, int startPos, int k) {
        unordered_map<int,int> m;
        for(auto i:v)m[i[0]]=i[1];
         int sum1=m[startPos];
        for(int i=startPos+1;i<=k+startPos;i++)
            sum1+=m[i];
         int res=sum1;
        int left=startPos-1,right=startPos+k;
        while(left>=0&&left<right)
        {
            res=max(res,sum1);
            sum1-=m[right];
            right--;
            sum1-=m[right];
            right--;
            sum1+=m[left];
            left--;
        }
            res=max(res,sum1);
            sum1=m[startPos],left=startPos-k,right=startPos+1;
            for(int i=startPos-1;i>=startPos-k;i--)
               sum1+=m[i];
        
          while(right<=v.back()[0]&&left<right)
           {
               res=max(res,sum1);
               sum1-=m[left];
               left++;
               sum1-=m[left];
               left++;
               sum1+=m[right];
               right++;
           }
            res=max(res,sum1);
        return res;
        
    }
};
Arpit
solution 1st question:-
class Solution {
public:
 int nthUglyNumber(int n, int a, int b, int c) {
       int start=1;
        int end=a*n;
        long int ab=(long int)a*b/gcd(a,b);
      long  int bc=(long int)c*b/gcd(c,b);
        long int ca=(long int)a*c/gcd(a,c);
         long int abc=(long int)a*bc/gcd(a,bc);
        while(start<end){
            int mid=start+(end-start)/2;
           int total=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ca+mid/abc;
           cout<<total<<" ";
            if(total<n){
                start=mid+1;
            }
            else
                end=mid;
        }
        return end;
    }
};

-----------------------------------------------------------------------------------------------------------------------------------------------------



Date:13/12/2021

Questions:
Gajendra -> https://leetcode.com/problems/partition-equal-subset-sum/
